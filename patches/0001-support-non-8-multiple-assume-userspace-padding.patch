From e80aa2843ab9030d2b4e3ed8f479fc8561d91120 Mon Sep 17 00:00:00 2001
From: Dafna Hirschfeld <dafna3@gmail.com>
Date: Tue, 4 Dec 2018 00:38:54 -0800
Subject: [PATCH] support non 8 multiple -assume userspace padding

---
 drivers/media/platform/vicodec/codec-fwht.c   | 76 +++++++++++++++----
 drivers/media/platform/vicodec/vicodec-core.c | 12 +--
 2 files changed, 68 insertions(+), 20 deletions(-)

diff --git a/drivers/media/platform/vicodec/codec-fwht.c b/drivers/media/platform/vicodec/codec-fwht.c
index 91cddf1c3f63..76a01ea07639 100644
--- a/drivers/media/platform/vicodec/codec-fwht.c
+++ b/drivers/media/platform/vicodec/codec-fwht.c
@@ -637,6 +637,7 @@ static void fill_decoder_block(u8 *dst, const s16 *input, int stride)
 	}
 }
 
+
 static void add_deltas(s16 *deltas, const u8 *ref, int stride)
 {
 	int k, l;
@@ -670,19 +671,48 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 	u32 encoding = 0;
 	unsigned int last_size = 0;
 	unsigned int i, j;
-	
+	u32 round_width = round_up(width, 8);
+	u32 round_height = round_up(height, 8);
+	u32 remainder_w = 8 - (round_width - width);
+	u32 remainder_h = 8 - (round_height - height);
+
 	pr_info("dafna: %s: start w=%u h=%u\n",__func__,width,height);
-	for (j = 0; j < height / 8; j++) {
-		for (i = 0; i < width / 8; i++) {
+	for (j = 0; j < round_height / 8; j++) {
+		for (i = 0; i < round_width / 8; i++) {
 			/* intra code, first frame is always intra coded. */
 			int blocktype = IBLOCK;
 			unsigned int size;
+			if(i == width / 8) {
+				pr_info("%s: danfa: in width edge i = %u, j = %u\n",__func__, i, j);
+				
+				u8 *in_p = input + input_step * remainder_w; 
+				for(int h = 0; h < remainder_h; h++) {
+					int p;
+					u8 last_val = *(in_p - input_step)
+					for(p=0; p < 8 - remainder_w; p++, in_p += input_step)
+						*in_p = last_val;
+					in_p += input_step * (round_width - (8 - remainder_w));
+				}
+			}
+			if(j == height / 8) {
+				pr_info("%s: danfa: in height edge i = %u, j = %u\n",__func__, i, j);
+				int h;
+				u8 *in_p = input + input_step * remainder_h * rounded_width; 
+				for(h = 0; h < 8 - remainder_h; h++) {
+					int p;
+					for(p=0; p < 8 ; p++, in_p += input_step)
+						*in_p = *(in_p - input_step * round_width);
+					in_p += input_step * (round_width - 8);
+				}
+			}
 
-			if (!is_intra)
+			if (!is_intra) 
 				blocktype = decide_blocktype(input, refp,
-					deltablock, width, input_step);
+					deltablock, width, input_step);	
+
 			if (blocktype == IBLOCK) {
 				fwht(input, cf->coeffs, width, input_step, 1);
+
 				quantize_intra(cf->coeffs, cf->de_coeffs,
 					       cf->i_frame_qp);
 			} else {
@@ -699,8 +729,8 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 					add_deltas(cf->de_fwht, refp, 8);
 				fill_decoder_block(refp, cf->de_fwht, 8);
 			}
-
 			input += 8 * input_step;
+
 			refp += 8 * 8;
 
 			size = rlc(cf->coeffs, *rlco, blocktype);
@@ -728,7 +758,6 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 
 exit_loop:
 	if (encoding & FWHT_FRAME_UNENCODED) {
-		pr_info("dafna: %s: plane unencoded\n",__func__);
 		u8 *out = (u8 *)rlco_start;
 
 		input = input_start;
@@ -790,7 +819,7 @@ u32 fwht_encode_frame(struct fwht_raw_frame *frm,
 
 	if (frm->components_num == 4) {
 		rlco_max = rlco + size / 2 - 256;
-		encoding = encode_plane(frm->alpha, ref_frm->alpha, &rlco,
+		encoding |= encode_plane(frm->alpha, ref_frm->alpha, &rlco,
 					rlco_max, cf, frm->height, frm->width,
 					frm->luma_alpha_step,
 					is_intra, next_is_intra);
@@ -809,6 +838,9 @@ static void decode_plane(struct fwht_cframe *cf, const __be16 **rlco, u8 *ref,
 	s16 copy[8 * 8];
 	s16 stat;
 	unsigned int i, j;
+	u8 edge_block[8 * 8];
+	u32 round_width = round_up(width, 8);
+	u32 round_height = round_up(height, 8);
 
 	if (uncompressed) {
 		memcpy(ref, *rlco, width * height);
@@ -822,15 +854,27 @@ static void decode_plane(struct fwht_cframe *cf, const __be16 **rlco, u8 *ref,
 	 * To avoid overflow the buffer has to be 65/64th of the actual raw
 	 * image size, just in case someone feeds it malicious data.
 	 */
-	for (j = 0; j < height / 8; j++) {
-		for (i = 0; i < width / 8; i++) {
+	for (j = 0; j < round_height / 8; j++) {
+		for (i = 0; i < round_width / 8; i++) {
 			u8 *refp = ref + j * 8 * width + i * 8;
 
+			bool edge = false;
+			if(i == width / 8 || j == height / 8) {
+				pr_info("%s: danfa: in edge i = %u, j = %u\n",__func__, i, j);
+
+				edge = true;
+				fill_edge_block(refp,edge_block,width,height,1);
+			}
 			if (copies) {
+				pr_info("%s: danfa: copies i = %u, j = %u\n",__func__, i, j);
+
 				memcpy(cf->de_fwht, copy, sizeof(copy));
 				if (stat & PFRAME_BIT)
-					add_deltas(cf->de_fwht, refp, width);
-				fill_decoder_block(refp, cf->de_fwht, width);
+					add_deltas(cf->de_fwht, edge ? edge_block : refp, edge ? 8 : width);
+				if(!edge)
+					fill_decoder_block(refp, cf->de_fwht, width);
+				else
+					fill_decoder_block_on_edge(refp, cf->de_fwht, width, height);
 				copies--;
 				continue;
 			}
@@ -849,8 +893,12 @@ static void decode_plane(struct fwht_cframe *cf, const __be16 **rlco, u8 *ref,
 			if (copies)
 				memcpy(copy, cf->de_fwht, sizeof(copy));
 			if (stat & PFRAME_BIT)
-				add_deltas(cf->de_fwht, refp, width);
-			fill_decoder_block(refp, cf->de_fwht, width);
+				add_deltas(cf->de_fwht, edge ? edge_block : refp, edge ? 8 : width);
+			if(!edge)
+				fill_decoder_block(refp, cf->de_fwht, width);
+			else
+				fill_decoder_block_on_edge(refp, cf->de_fwht, width, height);
+
 		}
 	}
 }
diff --git a/drivers/media/platform/vicodec/vicodec-core.c b/drivers/media/platform/vicodec/vicodec-core.c
index 4874594224ea..4b36376ffda0 100644
--- a/drivers/media/platform/vicodec/vicodec-core.c
+++ b/drivers/media/platform/vicodec/vicodec-core.c
@@ -1024,9 +1024,9 @@ static int vicodec_start_streaming(struct vb2_queue *q,
 	struct vicodec_ctx *ctx = vb2_get_drv_priv(q);
 	struct vicodec_q_data *q_data = get_q_data(ctx, q->type);
 	struct v4l2_fwht_state *state = &ctx->state;
-	unsigned int size = q_data->width * q_data->height;
 	const struct v4l2_fwht_pixfmt_info *info = q_data->info;
-	unsigned int chroma_div = info->width_div * info->height_div;
+	unsigned int size = round_up(q_data->width, 8) * round_up(q_data->height, 8);
+	unsigned int chroma_size = round_up(q_data->width/info->width_div, 8) * round_up(q_data->height/info->height_div, 8);
 	unsigned int total_planes_size;
 
 	/*
@@ -1034,9 +1034,9 @@ static int vicodec_start_streaming(struct vb2_queue *q,
 	 * V4L2_PIX_FMT_FWHT, so we will allocate space for 4 planes.
 	 */
 	if (info->id == V4L2_PIX_FMT_FWHT || info->components_num == 4)
-		total_planes_size = 2 * size + 2 * (size / chroma_div);
+		total_planes_size = 2 * size + 2 * chroma_size;
 	else if (info->components_num == 3)
-		total_planes_size = size + 2 * (size / chroma_div);
+		total_planes_size = size + 2 * chroma_size;
 	else
 		total_planes_size = size;
 
@@ -1067,7 +1067,7 @@ static int vicodec_start_streaming(struct vb2_queue *q,
 	}
 	if (info->id == V4L2_PIX_FMT_FWHT || info->components_num >= 3) {
 		state->ref_frame.cb = state->ref_frame.luma + size;
-		state->ref_frame.cr = state->ref_frame.cb + size / chroma_div;
+		state->ref_frame.cr = state->ref_frame.cb + chroma_size;
 	} else {
 		state->ref_frame.cb = NULL;
 		state->ref_frame.cr = NULL;
@@ -1075,7 +1075,7 @@ static int vicodec_start_streaming(struct vb2_queue *q,
 
 	if (info->id == V4L2_PIX_FMT_FWHT || info->components_num == 4)
 		state->ref_frame.alpha =
-			state->ref_frame.cr + size / chroma_div;
+			state->ref_frame.cr + chroma_size;
 	else
 		state->ref_frame.alpha = NULL;
 
-- 
2.17.1

