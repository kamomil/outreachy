From 4d9b6dc0e517d27682e1b4aca724ab952618ff6e Mon Sep 17 00:00:00 2001
From: Dafna Hirschfeld <dafna3@gmail.com>
Date: Tue, 13 Nov 2018 12:05:11 +0200
Subject: [PATCH 3/5] prints

---
 drivers/media/platform/vicodec/codec-fwht.c   | 10 +++--
 .../media/platform/vicodec/codec-v4l2-fwht.c  | 23 +++++++++-
 drivers/media/platform/vicodec/vicodec-core.c | 42 ++++++++++++++++---
 drivers/media/v4l2-core/v4l2-compat-ioctl32.c |  1 +
 drivers/media/v4l2-core/v4l2-dev.c            |  2 +-
 drivers/media/v4l2-core/v4l2-ioctl.c          |  9 +++-
 drivers/media/v4l2-core/v4l2-mem2mem.c        |  6 ++-
 7 files changed, 78 insertions(+), 15 deletions(-)

diff --git a/drivers/media/platform/vicodec/codec-fwht.c b/drivers/media/platform/vicodec/codec-fwht.c
index 5630f1dc45e6..91cddf1c3f63 100644
--- a/drivers/media/platform/vicodec/codec-fwht.c
+++ b/drivers/media/platform/vicodec/codec-fwht.c
@@ -11,7 +11,7 @@
 
 #include <linux/string.h>
 #include "codec-fwht.h"
-
+#include <linux/videodev2.h>
 /*
  * Note: bit 0 of the header must always be 0. Otherwise it cannot
  * be guaranteed that the magic 8 byte sequence (see below) can
@@ -670,7 +670,8 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 	u32 encoding = 0;
 	unsigned int last_size = 0;
 	unsigned int i, j;
-
+	
+	pr_info("dafna: %s: start w=%u h=%u\n",__func__,width,height);
 	for (j = 0; j < height / 8; j++) {
 		for (i = 0; i < width / 8; i++) {
 			/* intra code, first frame is always intra coded. */
@@ -727,6 +728,7 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 
 exit_loop:
 	if (encoding & FWHT_FRAME_UNENCODED) {
+		pr_info("dafna: %s: plane unencoded\n",__func__);
 		u8 *out = (u8 *)rlco_start;
 
 		input = input_start;
@@ -741,6 +743,7 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 		*rlco = (__be16 *)out;
 		encoding &= ~FWHT_FRAME_PCODED;
 	}
+	pr_info("dafna: %s: end\n",__func__);
 	return encoding;
 }
 
@@ -753,7 +756,7 @@ u32 fwht_encode_frame(struct fwht_raw_frame *frm,
 	__be16 *rlco = cf->rlc_data;
 	__be16 *rlco_max;
 	u32 encoding;
-
+	printk(KERN_DEBUG  "dafna: %s rlco = %p\n",__func__,rlco);
 	rlco_max = rlco + size / 2 - 256;
 	encoding = encode_plane(frm->luma, ref_frm->luma, &rlco, rlco_max, cf,
 				frm->height, frm->width,
@@ -795,7 +798,6 @@ u32 fwht_encode_frame(struct fwht_raw_frame *frm,
 			encoding |= FWHT_ALPHA_UNENCODED;
 		encoding &= ~FWHT_FRAME_UNENCODED;
 	}
-
 	cf->size = (rlco - cf->rlc_data) * sizeof(*rlco);
 	return encoding;
 }
diff --git a/drivers/media/platform/vicodec/codec-v4l2-fwht.c b/drivers/media/platform/vicodec/codec-v4l2-fwht.c
index 48d58b87f2eb..eac5108f388d 100644
--- a/drivers/media/platform/vicodec/codec-v4l2-fwht.c
+++ b/drivers/media/platform/vicodec/codec-v4l2-fwht.c
@@ -64,6 +64,7 @@ int v4l2_fwht_encode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	u32 encoding;
 	u32 flags = 0;
 
+	pr_info("dafna: %s\n",__func__);
 	if (!info)
 		return -EINVAL;
 	rf.width = state->width;
@@ -76,6 +77,7 @@ int v4l2_fwht_encode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	rf.alpha = NULL;
 	rf.components_num = info->components_num;
 
+	pr_info("dafna: %s: V4L2_PIX_FMT is %u\n",__func__, info->id);
 	switch (info->id) {
 	case V4L2_PIX_FMT_GREY:
 		rf.cb = NULL;
@@ -169,6 +171,8 @@ int v4l2_fwht_encode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	cf.p_frame_qp = state->p_frame_qp;
 	cf.rlc_data = (__be16 *)(p_out + sizeof(*p_hdr));
 
+	pr_info("dafna: %s: fr.cr = %p fr.cb = %p\n",__func__,rf.cr, rf.cb);
+
 	encoding = fwht_encode_frame(&rf, &state->ref_frame, &cf,
 				     !state->gop_cnt,
 				     state->gop_cnt == state->gop_size - 1);
@@ -225,8 +229,11 @@ int v4l2_fwht_decode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	unsigned int components_num = 3;
 	unsigned int version;
 
-	if (!state->info)
+	pr_info("dafna: %s\n",__func__);
+	if (!state->info){
+		pr_info("dafna: %s ERR: no info\n",__func__);
 		return -EINVAL;
+	}
 
 	p_hdr = (struct fwht_cframe_hdr *)p_in;
 	cf.width = ntohl(p_hdr->width);
@@ -243,6 +250,19 @@ int v4l2_fwht_decode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	    p_hdr->magic2 != FWHT_MAGIC2 ||
 	    (cf.width & 7) || (cf.height & 7))
 		return -EINVAL;
+	 }
+	 if(ntohl(p_hdr->version) != FWHT_VERSION){
+		pr_info("dafna: %s ERR version\n",__func__);
+		return -EINVAL;
+	
+	 }
+
+	 if((cf.width & 7) || (cf.height & 7)){
+		pr_info("dafna: %s ERR w=0x%x h=0x%x \n",__func__, cf.width, cf.height);
+		return -EINVAL;
+	}
+	pr_info("dafna: %s cf.width %u state->width %u cf.height %u state->height %u \n",
+			__func__,cf.width, state->width, cf.height, state->height);
 
 	/* TODO: support resolution changes */
 	if (cf.width != state->width || cf.height != state->height)
@@ -266,6 +286,7 @@ int v4l2_fwht_decode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	if (!(flags & FWHT_FL_CHROMA_FULL_HEIGHT))
 		chroma_size /= 2;
 
+	pr_info("dafna: %s, about to call decode with state->ref_frame.cr = %p, state->ref_frame.cb = %p\n",__func__, state->ref_frame.cr, state->ref_frame.cb);
 	fwht_decode_frame(&cf, &state->ref_frame, flags, components_num);
 
 	pr_info("DECODING luma UN compressed: %lu\n", flags & FWHT_FL_LUMA_IS_UNCOMPRESSED);
diff --git a/drivers/media/platform/vicodec/vicodec-core.c b/drivers/media/platform/vicodec/vicodec-core.c
index e75bc263a113..3ac866acc5e1 100644
--- a/drivers/media/platform/vicodec/vicodec-core.c
+++ b/drivers/media/platform/vicodec/vicodec-core.c
@@ -160,6 +160,7 @@ static int device_process(struct vicodec_ctx *ctx,
 	u8 *p_in, *p_out;
 	int ret;
 
+	pr_info("dafna: %s\n",__func__);
 	q_cap = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);
 	if (ctx->is_enc)
 		p_in = vb2_plane_vaddr(&in_vb->vb2_buf, 0);
@@ -177,12 +178,14 @@ static int device_process(struct vicodec_ctx *ctx,
 
 		q_out = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);
 		state->info = q_out->info;
+		pr_info("dafna: %s: aboout to call v4l2_fwht_encode\n", __func__);
 		ret = v4l2_fwht_encode(state, p_in, p_out);
 		if (ret < 0)
 			return ret;
 		vb2_set_plane_payload(&out_vb->vb2_buf, 0, ret);
 	} else {
 		state->info = q_cap->info;
+		pr_info("dafna: %s: aboout to call v4l2_fwht_decode\n", __func__);
 		ret = v4l2_fwht_decode(state, p_in, p_out);
 		if (ret < 0)
 			return ret;
@@ -222,11 +225,13 @@ static void device_run(void *priv)
 	struct vicodec_q_data *q_out;
 	u32 state;
 
+	pr_info("dafna: %s ctx = %p\n",__func__, ctx);
 	src_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);
 	dst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
 	q_out = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);
 
 	state = VB2_BUF_STATE_DONE;
+	pr_info("dafna: %s: about to call device_process\n",__func__);
 	if (device_process(ctx, src_buf, dst_buf))
 		state = VB2_BUF_STATE_ERROR;
 	ctx->last_dst_buf = dst_buf;
@@ -285,6 +290,7 @@ static int job_ready(void *priv)
 	u32 sz;
 	u32 state;
 
+	pr_info("dafna: %s\n", __func__);
 	if (ctx->is_enc || ctx->comp_has_frame)
 		return 1;
 
@@ -313,6 +319,8 @@ static int job_ready(void *priv)
 			copy = sizeof(magic) - ctx->comp_magic_cnt;
 			if (p_out + sz - p < copy)
 				copy = p_out + sz - p;
+			pr_info("dafna: %s copying %u to compressed_frame\n", __func__,copy);
+
 			memcpy(ctx->state.compressed_frame + ctx->comp_magic_cnt,
 			       p, copy);
 			ctx->comp_magic_cnt += copy;
@@ -337,6 +345,7 @@ static int job_ready(void *priv)
 
 		if (copy > p_out + sz - p)
 			copy = p_out + sz - p;
+		pr_info("dafna: %s copying AGAIN %u to compressed_frame\n", __func__,copy);
 		memcpy(ctx->state.compressed_frame + ctx->comp_size,
 		       p, copy);
 		p += copy;
@@ -354,6 +363,9 @@ static int job_ready(void *priv)
 
 		if (copy > p_out + sz - p)
 			copy = p_out + sz - p;
+		
+		pr_info("dafna: %s copying AGAIN AGAIN %u to compressed_frame\n", __func__,copy);
+
 		memcpy(ctx->state.compressed_frame + ctx->comp_size,
 		       p, copy);
 		p += copy;
@@ -405,6 +417,7 @@ static int enum_fmt(struct v4l2_fmtdesc *f, bool is_enc, bool is_out)
 {
 	bool is_uncomp = (is_enc && is_out) || (!is_enc && !is_out);
 
+	pr_info("dafna: enum_fmt\n");
 	if (V4L2_TYPE_IS_MULTIPLANAR(f->type) && !multiplanar)
 		return -EINVAL;
 	if (!V4L2_TYPE_IS_MULTIPLANAR(f->type) && multiplanar)
@@ -456,6 +469,7 @@ static int vidioc_g_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 	q_data = get_q_data(ctx, f->type);
 	info = q_data->info;
 
+	pr_info("dafna: vidioc_g_fmt\n");
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
@@ -467,6 +481,8 @@ static int vidioc_g_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 		pix->field = V4L2_FIELD_NONE;
 		pix->pixelformat = info->id;
 		pix->bytesperline = q_data->width * info->bytesperline_mult;
+		pr_info("dafna: %s: set pix->bytesperline(%u) = q_data->width(%u) * info->bytesperline_mult (%u)\n",__func__,
+				pix->bytesperline,q_data->width,info->bytesperline_mult);
 		pix->sizeimage = q_data->sizeimage;
 		pix->colorspace = ctx->state.colorspace;
 		pix->xfer_func = ctx->state.xfer_func;
@@ -486,6 +502,8 @@ static int vidioc_g_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 		pix_mp->num_planes = 1;
 		pix_mp->plane_fmt[0].bytesperline =
 				q_data->width * info->bytesperline_mult;
+		pr_info("dafna: %s: set pix_mp->plane_fmt[0].bytesperline(%u) = q_data->width(%u) * info->bytesperline_mult (%u)\n",__func__,
+				pix_mp->plane_fmt[0].bytesperline,q_data->width,info->bytesperline_mult);
 		pix_mp->plane_fmt[0].sizeimage = q_data->sizeimage;
 		pix_mp->colorspace = ctx->state.colorspace;
 		pix_mp->xfer_func = ctx->state.xfer_func;
@@ -519,7 +537,8 @@ static int vidioc_try_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 	struct v4l2_pix_format *pix;
 	struct v4l2_plane_pix_format *plane;
 	const struct v4l2_fwht_pixfmt_info *info = &pixfmt_fwht;
-
+	
+	pr_info("dafna: %s\n",__func__);
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
@@ -531,8 +550,13 @@ static int vidioc_try_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 		pix->field = V4L2_FIELD_NONE;
 		pix->bytesperline =
 			pix->width * info->bytesperline_mult;
+		pr_info("dafna: %s: set pix->bytesperline(%u) = pix->width(%u) * info->bytesperline_mult (%u)\n",__func__, 
+				pix->bytesperline,pix->width,info->bytesperline_mult);
 		pix->sizeimage = pix->width * pix->height *
 			info->sizeimage_mult / info->sizeimage_div;
+		pr_info("dafna: %s: pix->sizeimage (%u) = pix->width (%u) * pix->height (%u) * info->sizeimage_mult (%u)/ info->sizeimage_div (%u)\n",__func__, pix->sizeimage, pix->width, pix->height,
+			info->sizeimage_mult, info->sizeimage_div);
+
 		if (pix->pixelformat == V4L2_PIX_FMT_FWHT)
 			pix->sizeimage += sizeof(struct fwht_cframe_hdr);
 		break;
@@ -569,7 +593,7 @@ static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
 	struct vicodec_ctx *ctx = file2ctx(file);
 	struct v4l2_pix_format_mplane *pix_mp;
 	struct v4l2_pix_format *pix;
-
+	pr_info("dafna: %s\n",__func__);
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 		if (multiplanar)
@@ -606,7 +630,7 @@ static int vidioc_try_fmt_vid_out(struct file *file, void *priv,
 	struct vicodec_ctx *ctx = file2ctx(file);
 	struct v4l2_pix_format_mplane *pix_mp;
 	struct v4l2_pix_format *pix;
-
+	pr_info("dafna: %s\n",__func__);
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
 		if (multiplanar)
@@ -641,6 +665,7 @@ static int vidioc_s_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 	struct v4l2_pix_format_mplane *pix_mp;
 	struct v4l2_pix_format *pix;
 
+	pr_info("dafna: vidioc_s_fmt\n");
 	vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);
 	if (!vq)
 		return -EINVAL;
@@ -705,7 +730,7 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 				struct v4l2_format *f)
 {
 	int ret;
-
+	pr_info("dafna: %s\n",__func__);
 	ret = vidioc_try_fmt_vid_cap(file, priv, f);
 	if (ret)
 		return ret;
@@ -721,6 +746,7 @@ static int vidioc_s_fmt_vid_out(struct file *file, void *priv,
 	struct v4l2_pix_format *pix;
 	int ret;
 
+	pr_info("dafna: in vidioc_s_fmt_vid_out\n");
 	ret = vidioc_try_fmt_vid_out(file, priv, f);
 	if (ret)
 		return ret;
@@ -730,7 +756,9 @@ static int vidioc_s_fmt_vid_out(struct file *file, void *priv,
 		switch (f->type) {
 		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 		case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+			pr_info("dafna: %s: case V4L2_BUF_TYPE_VIDEO_OUTPUT/CAPTURE: setting ctx from format\n",__func__);
 			pix = &f->fmt.pix;
+			pr_info("dafna: %s: case V4L2_.._OUTPUT/CAPTURE: setting ctx from format %d\n",__func__, pix->pixelformat);
 			ctx->state.colorspace = pix->colorspace;
 			ctx->state.xfer_func = pix->xfer_func;
 			ctx->state.ycbcr_enc = pix->ycbcr_enc;
@@ -1004,6 +1032,7 @@ static int vicodec_start_streaming(struct vb2_queue *q,
 
 	q_data->sequence = 0;
 
+	pr_info("dafna: %s ctx=%p, id=%u\n",__func__, ctx, info->id);
 	if (!V4L2_TYPE_IS_OUTPUT(q->type)) {
 		if (!ctx->is_enc) {
 			state->width = q_data->width;
@@ -1079,7 +1108,7 @@ static int queue_init(void *priv, struct vb2_queue *src_vq,
 {
 	struct vicodec_ctx *ctx = priv;
 	int ret;
-
+	pr_info("dafna: %s\n",__func__);
 	src_vq->type = (multiplanar ?
 			V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE :
 			V4L2_BUF_TYPE_VIDEO_OUTPUT);
@@ -1118,7 +1147,7 @@ static int vicodec_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct vicodec_ctx *ctx = container_of(ctrl->handler,
 					       struct vicodec_ctx, hdl);
-
+	pr_info("dafna: %s\n",__func__);
 	switch (ctrl->id) {
 	case V4L2_CID_MPEG_VIDEO_GOP_SIZE:
 		ctx->state.gop_size = ctrl->val;
@@ -1171,6 +1200,7 @@ static int vicodec_open(struct file *file)
 	unsigned int size;
 	int rc = 0;
 
+	pr_info("dafna: %s\n",__func__);
 	if (mutex_lock_interruptible(vfd->lock))
 		return -ERESTARTSYS;
 	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
diff --git a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c
index f4325329fbd6..37a4fa5b4428 100644
--- a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c
+++ b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c
@@ -1247,6 +1247,7 @@ static long do_video_ioctl(struct file *file, unsigned int cmd, unsigned long ar
 	case VIDIOC_G_FMT:
 	case VIDIOC_S_FMT:
 	case VIDIOC_TRY_FMT:
+        pr_info("do_video_ioctl: case VIDIOC_G_FMT/VIDIOC_G_FMT/VIDIOC_TRY_FMT %d\n",cmd);
 		err = bufsize_v4l2_format(p32, &aux_space);
 		if (!err)
 			err = alloc_userspace(sizeof(struct v4l2_format),
diff --git a/drivers/media/v4l2-core/v4l2-dev.c b/drivers/media/v4l2-core/v4l2-dev.c
index 2130e3a0f4da..92413e3b3edb 100644
--- a/drivers/media/v4l2-core/v4l2-dev.c
+++ b/drivers/media/v4l2-core/v4l2-dev.c
@@ -1062,7 +1062,7 @@ static int __init videodev_init(void)
 	dev_t dev = MKDEV(VIDEO_MAJOR, 0);
 	int ret;
 
-	pr_info("Linux video capture interface: v2.00\n");
+	pr_info("Linux video capture interface: v2.00 dafna\n");
 	ret = register_chrdev_region(dev, VIDEO_NUM_DEVICES, VIDEO_NAME);
 	if (ret < 0) {
 		pr_warn("videodev: unable to get major %d\n",
diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2-ioctl.c
index e384142d2826..270277610435 100644
--- a/drivers/media/v4l2-core/v4l2-ioctl.c
+++ b/drivers/media/v4l2-core/v4l2-ioctl.c
@@ -1513,9 +1513,12 @@ static int v4l_s_fmt(const struct v4l2_ioctl_ops *ops,
 	struct video_device *vfd = video_devdata(file);
 	int ret = check_fmt(file, p->type);
 
+	pr_info("dafna: in v4l_s_fmt");
 	if (ret)
 		return ret;
 
+	//this does mothing for most drivers
+	//as enable_source is not defined
 	ret = v4l_enable_media_source(vfd);
 	if (ret)
 		return ret;
@@ -1553,12 +1556,16 @@ static int v4l_s_fmt(const struct v4l2_ioctl_ops *ops,
 		CLEAR_AFTER_FIELD(p, fmt.sliced);
 		return ops->vidioc_s_fmt_sliced_vbi_cap(file, fh, arg);
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-		if (unlikely(!ops->vidioc_s_fmt_vid_out))
+		if (unlikely(!ops->vidioc_s_fmt_vid_out)){
+			pr_info("dafna: %s: ops->vidioc_s_fmt_vid_out not defined\n",__func__);
 			break;
+		}
 		CLEAR_AFTER_FIELD(p, fmt.pix);
+		pr_info("dafna: calling ops->vidioc_s_fmt_vid_out\n");
 		ret = ops->vidioc_s_fmt_vid_out(file, fh, arg);
 		/* just in case the driver zeroed it again */
 		p->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;
+		pr_info("dafna: %s: returning %d\n",__func__, ret);
 		return ret;
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
 		if (unlikely(!ops->vidioc_s_fmt_vid_out_mplane))
diff --git a/drivers/media/v4l2-core/v4l2-mem2mem.c b/drivers/media/v4l2-core/v4l2-mem2mem.c
index 5bbdec55b7d7..bf0ec16d4951 100644
--- a/drivers/media/v4l2-core/v4l2-mem2mem.c
+++ b/drivers/media/v4l2-core/v4l2-mem2mem.c
@@ -273,6 +273,7 @@ static void v4l2_m2m_try_run(struct v4l2_m2m_dev *m2m_dev)
 	spin_unlock_irqrestore(&m2m_dev->job_spinlock, flags);
 
 	dprintk("Running job on m2m_ctx: %p\n", m2m_dev->curr_ctx);
+	pr_info("dafna: %s: about to call device_run callback, m2m_dev = %p\n",__func__, m2m_dev);
 	m2m_dev->m2m_ops->device_run(m2m_dev->curr_ctx->priv);
 }
 
@@ -361,7 +362,7 @@ static void __v4l2_m2m_try_queue(struct v4l2_m2m_dev *m2m_dev,
 void v4l2_m2m_try_schedule(struct v4l2_m2m_ctx *m2m_ctx)
 {
 	struct v4l2_m2m_dev *m2m_dev = m2m_ctx->m2m_dev;
-
+	pr_info("dafna: %s: m2m_dev = %p\n",__func__, m2m_dev);
 	__v4l2_m2m_try_queue(m2m_dev, m2m_ctx);
 	v4l2_m2m_try_run(m2m_dev);
 }
@@ -1054,7 +1055,8 @@ int v4l2_m2m_ioctl_qbuf(struct file *file, void *priv,
 				struct v4l2_buffer *buf)
 {
 	struct v4l2_fh *fh = file->private_data;
-
+	pr_info("dafna: %s: v4l2_fh = %p\n",__func__, fh);
+	
 	return v4l2_m2m_qbuf(file, fh->m2m_ctx, buf);
 }
 EXPORT_SYMBOL_GPL(v4l2_m2m_ioctl_qbuf);
-- 
2.17.1

