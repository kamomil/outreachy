From 06565e7acec4ba1ee354768ab445693fdc9c0de2 Mon Sep 17 00:00:00 2001
From: Dafna Hirschfeld <dafna3@gmail.com>
Date: Mon, 3 Dec 2018 06:22:41 -0800
Subject: [PATCH] support edge in codec-fwht assume no userspace paddig

This is an old implementation assuming no padding from userspace
---
 drivers/media/platform/vicodec/codec-fwht.c   | 123 +++++++++++++++---
 drivers/media/platform/vicodec/vicodec-core.c |  12 +-
 2 files changed, 113 insertions(+), 22 deletions(-)

diff --git a/drivers/media/platform/vicodec/codec-fwht.c b/drivers/media/platform/vicodec/codec-fwht.c
index 91cddf1c3f63..fedaab12b80d 100644
--- a/drivers/media/platform/vicodec/codec-fwht.c
+++ b/drivers/media/platform/vicodec/codec-fwht.c
@@ -637,6 +637,29 @@ static void fill_decoder_block(u8 *dst, const s16 *input, int stride)
 	}
 }
 
+static void fill_decoder_block_on_edge(u8 *dst, const s16 *input, u32 width, u32 height)
+{
+	int i, j;
+
+	u32 width_remainder = 8 - (round_up(width,8) - width);
+        u32 height_remainder = 8 - (round_up(height,8) - height);
+
+	for (i = 0; i < height_remainder; i++) {
+		for (j = 0; j < width_remainder; j++, input++, dst++) {
+
+			if (*input < 0)
+				*dst = 0;
+			else if (*input > 255)
+				*dst = 255;
+			else
+				*dst = *input;
+		}
+		input += 8 - width_remainder;
+		dst += width - width_remainder;
+	}
+}
+
+
 static void add_deltas(s16 *deltas, const u8 *ref, int stride)
 {
 	int k, l;
@@ -658,6 +681,31 @@ static void add_deltas(s16 *deltas, const u8 *ref, int stride)
 	}
 }
 
+static void fill_edge_block(const u8* input,u8* edge_block,u32 width,u32 height,unsigned int input_step) {
+
+	u32 width_remainder = (8 - (round_up(width,8) - width));
+	u32 height_remainder = (8 - (round_up(height,8) - height));
+
+	int j, i;
+	int k = 0;
+	for(j = 0; j < 8; j++) {
+		for(i = 0; i < 8; i++) {
+			if(i>=width_remainder) {
+				edge_block[k] = edge_block[k-1];
+			}
+			else if(j>=height_remainder) {
+				edge_block[k] = edge_block[k-8];
+			}
+			else {
+				edge_block[k] = *input;
+			}
+			input += input_step;
+			k++;
+		}
+		input += (width - 8) * input_step;
+	}
+}
+
 static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 			struct fwht_cframe *cf, u32 height, u32 width,
 			unsigned int input_step,
@@ -670,19 +718,41 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 	u32 encoding = 0;
 	unsigned int last_size = 0;
 	unsigned int i, j;
-	
+	u32 round_width = round_up(width, 8);
+	u32 round_height = round_up(height, 8);
+	u8 edge_block[8 * 8];
 	pr_info("dafna: %s: start w=%u h=%u\n",__func__,width,height);
-	for (j = 0; j < height / 8; j++) {
-		for (i = 0; i < width / 8; i++) {
+	for (j = 0; j < round_height / 8; j++) {
+		for (i = 0; i < round_width / 8; i++) {
 			/* intra code, first frame is always intra coded. */
 			int blocktype = IBLOCK;
 			unsigned int size;
+			bool edge = false;
+			if(i == width / 8 || j == height / 8) {
+				pr_info("%s: danfa: in edge i = %u, j = %u\n",__func__, i, j);
+				edge = true;
+				fill_edge_block(input,edge_block,width,height,input_step);
+			}
+
+			if (!is_intra) {
+				if(!edge) {
+					blocktype = decide_blocktype(input, refp,
+						deltablock, width, input_step);
+				} else {
+					pr_info("%s: danfa: edge i = %u, j = %u, calling decide_blocktype\n",__func__, i, j);
+					blocktype = decide_blocktype(edge_block, refp,
+						deltablock, 8, 1);
+				}
+			}
 
-			if (!is_intra)
-				blocktype = decide_blocktype(input, refp,
-					deltablock, width, input_step);
 			if (blocktype == IBLOCK) {
-				fwht(input, cf->coeffs, width, input_step, 1);
+				if(!edge) {
+					fwht(input, cf->coeffs, width, input_step, 1);
+				} else {
+					pr_info("%s: danfa: in edge i = %u, j = %u, calling fwht\n",__func__, i, j);
+					fwht(edge_block, cf->coeffs, 8, 1, 1);
+				}
+
 				quantize_intra(cf->coeffs, cf->de_coeffs,
 					       cf->i_frame_qp);
 			} else {
@@ -699,8 +769,11 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 					add_deltas(cf->de_fwht, refp, 8);
 				fill_decoder_block(refp, cf->de_fwht, 8);
 			}
+			if(edge)
+				input += (8 - (round_width - width)) * input_step;
+			else
+				input += 8 * input_step;
 
-			input += 8 * input_step;
 			refp += 8 * 8;
 
 			size = rlc(cf->coeffs, *rlco, blocktype);
@@ -728,7 +801,6 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 
 exit_loop:
 	if (encoding & FWHT_FRAME_UNENCODED) {
-		pr_info("dafna: %s: plane unencoded\n",__func__);
 		u8 *out = (u8 *)rlco_start;
 
 		input = input_start;
@@ -790,7 +862,7 @@ u32 fwht_encode_frame(struct fwht_raw_frame *frm,
 
 	if (frm->components_num == 4) {
 		rlco_max = rlco + size / 2 - 256;
-		encoding = encode_plane(frm->alpha, ref_frm->alpha, &rlco,
+		encoding |= encode_plane(frm->alpha, ref_frm->alpha, &rlco,
 					rlco_max, cf, frm->height, frm->width,
 					frm->luma_alpha_step,
 					is_intra, next_is_intra);
@@ -809,6 +881,9 @@ static void decode_plane(struct fwht_cframe *cf, const __be16 **rlco, u8 *ref,
 	s16 copy[8 * 8];
 	s16 stat;
 	unsigned int i, j;
+	u8 edge_block[8 * 8];
+	u32 round_width = round_up(width, 8);
+	u32 round_height = round_up(height, 8);
 
 	if (uncompressed) {
 		memcpy(ref, *rlco, width * height);
@@ -822,15 +897,27 @@ static void decode_plane(struct fwht_cframe *cf, const __be16 **rlco, u8 *ref,
 	 * To avoid overflow the buffer has to be 65/64th of the actual raw
 	 * image size, just in case someone feeds it malicious data.
 	 */
-	for (j = 0; j < height / 8; j++) {
-		for (i = 0; i < width / 8; i++) {
+	for (j = 0; j < round_height / 8; j++) {
+		for (i = 0; i < round_width / 8; i++) {
 			u8 *refp = ref + j * 8 * width + i * 8;
 
+			bool edge = false;
+			if(i == width / 8 || j == height / 8) {
+				pr_info("%s: danfa: in edge i = %u, j = %u\n",__func__, i, j);
+
+				edge = true;
+				fill_edge_block(refp,edge_block,width,height,1);
+			}
 			if (copies) {
+				pr_info("%s: danfa: copies i = %u, j = %u\n",__func__, i, j);
+
 				memcpy(cf->de_fwht, copy, sizeof(copy));
 				if (stat & PFRAME_BIT)
-					add_deltas(cf->de_fwht, refp, width);
-				fill_decoder_block(refp, cf->de_fwht, width);
+					add_deltas(cf->de_fwht, edge ? edge_block : refp, edge ? 8 : width);
+				if(!edge)
+					fill_decoder_block(refp, cf->de_fwht, width);
+				else
+					fill_decoder_block_on_edge(refp, cf->de_fwht, width, height);
 				copies--;
 				continue;
 			}
@@ -849,8 +936,12 @@ static void decode_plane(struct fwht_cframe *cf, const __be16 **rlco, u8 *ref,
 			if (copies)
 				memcpy(copy, cf->de_fwht, sizeof(copy));
 			if (stat & PFRAME_BIT)
-				add_deltas(cf->de_fwht, refp, width);
-			fill_decoder_block(refp, cf->de_fwht, width);
+				add_deltas(cf->de_fwht, edge ? edge_block : refp, edge ? 8 : width);
+			if(!edge)
+				fill_decoder_block(refp, cf->de_fwht, width);
+			else
+				fill_decoder_block_on_edge(refp, cf->de_fwht, width, height);
+
 		}
 	}
 }
diff --git a/drivers/media/platform/vicodec/vicodec-core.c b/drivers/media/platform/vicodec/vicodec-core.c
index 4874594224ea..4b36376ffda0 100644
--- a/drivers/media/platform/vicodec/vicodec-core.c
+++ b/drivers/media/platform/vicodec/vicodec-core.c
@@ -1024,9 +1024,9 @@ static int vicodec_start_streaming(struct vb2_queue *q,
 	struct vicodec_ctx *ctx = vb2_get_drv_priv(q);
 	struct vicodec_q_data *q_data = get_q_data(ctx, q->type);
 	struct v4l2_fwht_state *state = &ctx->state;
-	unsigned int size = q_data->width * q_data->height;
 	const struct v4l2_fwht_pixfmt_info *info = q_data->info;
-	unsigned int chroma_div = info->width_div * info->height_div;
+	unsigned int size = round_up(q_data->width, 8) * round_up(q_data->height, 8);
+	unsigned int chroma_size = round_up(q_data->width/info->width_div, 8) * round_up(q_data->height/info->height_div, 8);
 	unsigned int total_planes_size;
 
 	/*
@@ -1034,9 +1034,9 @@ static int vicodec_start_streaming(struct vb2_queue *q,
 	 * V4L2_PIX_FMT_FWHT, so we will allocate space for 4 planes.
 	 */
 	if (info->id == V4L2_PIX_FMT_FWHT || info->components_num == 4)
-		total_planes_size = 2 * size + 2 * (size / chroma_div);
+		total_planes_size = 2 * size + 2 * chroma_size;
 	else if (info->components_num == 3)
-		total_planes_size = size + 2 * (size / chroma_div);
+		total_planes_size = size + 2 * chroma_size;
 	else
 		total_planes_size = size;
 
@@ -1067,7 +1067,7 @@ static int vicodec_start_streaming(struct vb2_queue *q,
 	}
 	if (info->id == V4L2_PIX_FMT_FWHT || info->components_num >= 3) {
 		state->ref_frame.cb = state->ref_frame.luma + size;
-		state->ref_frame.cr = state->ref_frame.cb + size / chroma_div;
+		state->ref_frame.cr = state->ref_frame.cb + chroma_size;
 	} else {
 		state->ref_frame.cb = NULL;
 		state->ref_frame.cr = NULL;
@@ -1075,7 +1075,7 @@ static int vicodec_start_streaming(struct vb2_queue *q,
 
 	if (info->id == V4L2_PIX_FMT_FWHT || info->components_num == 4)
 		state->ref_frame.alpha =
-			state->ref_frame.cr + size / chroma_div;
+			state->ref_frame.cr + chroma_size;
 	else
 		state->ref_frame.alpha = NULL;
 
-- 
2.17.1

