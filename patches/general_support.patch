diff --git a/drivers/media/platform/vicodec/codec-fwht.c b/drivers/media/platform/vicodec/codec-fwht.c
index 36656031b295..2da761d4a86b 100644
--- a/drivers/media/platform/vicodec/codec-fwht.c
+++ b/drivers/media/platform/vicodec/codec-fwht.c
@@ -11,7 +11,7 @@
 
 #include <linux/string.h>
 #include "codec-fwht.h"
-
+#include <linux/videodev2.h>
 /*
  * Note: bit 0 of the header must always be 0. Otherwise it cannot
  * be guaranteed that the magic 8 byte sequence (see below) can
@@ -670,7 +670,8 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 	u32 encoding = 0;
 	unsigned int last_size = 0;
 	unsigned int i, j;
-
+	
+	pr_info("dafna: %s: start w=%u h=%u\n",__func__,width,height);
 	for (j = 0; j < height / 8; j++) {
 		for (i = 0; i < width / 8; i++) {
 			/* intra code, first frame is always intra coded. */
@@ -728,6 +729,7 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 exit_loop:
 	if (encoding & FWHT_FRAME_UNENCODED) {
 		u8 *out = (u8 *)rlco_start;
+		pr_info("dafna: %s: plane unencoded\n",__func__);
 
 		input = input_start;
 		/*
@@ -741,6 +743,7 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 		*rlco = (__be16 *)out;
 		encoding &= ~FWHT_FRAME_PCODED;
 	}
+	pr_info("dafna: %s: end\n",__func__);
 	return encoding;
 }
 
@@ -749,35 +752,44 @@ u32 fwht_encode_frame(struct fwht_raw_frame *frm,
 		      struct fwht_cframe *cf,
 		      bool is_intra, bool next_is_intra)
 {
-	unsigned int size = frm->height * frm->width;
 	__be16 *rlco = cf->rlc_data;
 	__be16 *rlco_max;
-	u32 encoding;
-	u32 chroma_h = frm->height / frm->height_div;
-	u32 chroma_w = frm->width / frm->width_div;
-	unsigned int chroma_size = chroma_h * chroma_w;
-
-	rlco_max = rlco + size / 2 - 256;
-	encoding = encode_plane(frm->luma, ref_frm->luma, &rlco, rlco_max, cf,
-				frm->height, frm->width,
-				frm->luma_step, is_intra, next_is_intra);
-	if (encoding & FWHT_FRAME_UNENCODED)
-		encoding |= FWHT_LUMA_UNENCODED;
-	encoding &= ~FWHT_FRAME_UNENCODED;
-	rlco_max = rlco + chroma_size / 2 - 256;
-	encoding |= encode_plane(frm->cb, ref_frm->cb, &rlco, rlco_max, cf,
-				 chroma_h, chroma_w,
-				 frm->chroma_step, is_intra, next_is_intra);
-	if (encoding & FWHT_FRAME_UNENCODED)
-		encoding |= FWHT_CB_UNENCODED;
-	encoding &= ~FWHT_FRAME_UNENCODED;
-	rlco_max = rlco + chroma_size / 2 - 256;
-	encoding |= encode_plane(frm->cr, ref_frm->cr, &rlco, rlco_max, cf,
-				 chroma_h, chroma_w,
-				 frm->chroma_step, is_intra, next_is_intra);
-	if (encoding & FWHT_FRAME_UNENCODED)
-		encoding |= FWHT_CR_UNENCODED;
-	encoding &= ~FWHT_FRAME_UNENCODED;
+	u32 encoding = 0;
+
+	unsigned int i;
+	unsigned long flags[FWHT_MAX_COMPONENTS] = {FWHT_LUMA_UNENCODED,
+						FWHT_CB_UNENCODED,
+						FWHT_CR_UNENCODED,
+						FWHT_ALPHA_UNENCODED};
+
+	
+	for (i = 0; i < frm->components_num; i++){
+		u32 plane_h = frm->height / frm->component[i].height_div;
+		u32 plane_w = frm->width  / frm->component[i].width_div;
+		unsigned int size = plane_h * plane_w;
+		
+		printk(KERN_DEBUG  "dafna: %s rlco = %p\n",__func__,rlco);	
+		printk(KERN_DEBUG  "dafna: %s i=%u, frm->component[i].plane %p",__func__, i, frm->component[i].plane);
+		printk(KERN_DEBUG  "dafna: %s i=%u, h = %u w = %u",__func__, i, plane_h, plane_w);
+		printk(KERN_DEBUG  "dafna: %s i=%u, dumping start of component[i].plane",__func__, i);
+		print_hex_dump_bytes("", DUMP_PREFIX_NONE, frm->component[i].plane,10);
+
+
+		rlco_max = rlco + size / 2 - 256;
+		encoding |= encode_plane(frm->component[i].plane, ref_frm->component[i].plane, &rlco, rlco_max, cf,
+					plane_h, plane_w,
+					frm->component[i].step, is_intra, next_is_intra);
+		if (encoding & FWHT_FRAME_UNENCODED)
+			encoding |= flags[i];
+		encoding &= ~FWHT_FRAME_UNENCODED;
+
+		printk(KERN_DEBUG  "dafna: %s i=%u, dumping 10 bytes of cf->rlc_data(%p)",
+				__func__, i, cf->rlc_data);
+		print_hex_dump_bytes("", DUMP_PREFIX_NONE, cf->rlc_data,10);
+	}
+	printk(KERN_DEBUG  "dafna: %s\n: end, cf->rlc_data = %p, rlco = %p\n",__func__,
+			cf->rlc_data, rlco);
+
 	cf->size = (rlco - cf->rlc_data) * sizeof(*rlco);
 	return encoding;
 }
@@ -836,20 +848,38 @@ static void decode_plane(struct fwht_cframe *cf, const __be16 **rlco, u8 *ref,
 }
 
 void fwht_decode_frame(struct fwht_cframe *cf, struct fwht_raw_frame *ref,
-		       u32 hdr_flags)
+		       u32 hdr_flags, unsigned int components_num)
 {
 	const __be16 *rlco = cf->rlc_data;
 	u32 h = cf->height / 2;
 	u32 w = cf->width / 2;
-
+	unsigned int i;
+	u32 width[FWHT_MAX_COMPONENTS] = {0};
+	u32 height[FWHT_MAX_COMPONENTS] = {0};
+	unsigned long flags[FWHT_MAX_COMPONENTS] = {FWHT_FL_LUMA_IS_UNCOMPRESSED,
+				FWHT_FL_CB_IS_UNCOMPRESSED,
+				FWHT_FL_CR_IS_UNCOMPRESSED,
+				FWHT_FL_ALPHA_IS_UNCOMPRESSED};
+
+	//printk(KERN_DEBUG "dafna: %s\n",__func__);
 	if (hdr_flags & FWHT_FL_CHROMA_FULL_HEIGHT)
 		h *= 2;
 	if (hdr_flags & FWHT_FL_CHROMA_FULL_WIDTH)
 		w *= 2;
-	decode_plane(cf, &rlco, ref->luma, cf->height, cf->width,
-		     hdr_flags & FWHT_FL_LUMA_IS_UNCOMPRESSED);
-	decode_plane(cf, &rlco, ref->cb, h, w,
-		     hdr_flags & FWHT_FL_CB_IS_UNCOMPRESSED);
-	decode_plane(cf, &rlco, ref->cr, h, w,
-		     hdr_flags & FWHT_FL_CR_IS_UNCOMPRESSED);
+	
+	width[0] = cf->width;
+	width[1] = width[2] = width[3] = w;
+
+	height[0] = cf->height;
+	height[1] = height[2] = height[3] = h;
+
+	
+	for (i = 0; i < components_num; i++) {
+	
+		printk(KERN_DEBUG  "dafna: %s\n: i=%u h=%u w=%u plane = %p hdr_flgs = 0x%x \n",__func__,
+                        i, height[i], width[i], ref->component[i].plane, hdr_flags);
+
+		decode_plane(cf, &rlco, ref->component[i].plane, height[i], width[i],
+			     hdr_flags & flags[i]);
+	}
 }
diff --git a/drivers/media/platform/vicodec/codec-fwht.h b/drivers/media/platform/vicodec/codec-fwht.h
index 3e9391fec5fe..b5096bb1e44b 100644
--- a/drivers/media/platform/vicodec/codec-fwht.h
+++ b/drivers/media/platform/vicodec/codec-fwht.h
@@ -56,7 +56,7 @@
 #define FWHT_MAGIC1 0x4f4f4f4f
 #define FWHT_MAGIC2 0xffffffff
 
-#define FWHT_VERSION 1
+#define FWHT_VERSION 2
 
 /* Set if this is an interlaced format */
 #define FWHT_FL_IS_INTERLACED		BIT(0)
@@ -73,14 +73,16 @@
 #define FWHT_FL_LUMA_IS_UNCOMPRESSED	BIT(4)
 #define FWHT_FL_CB_IS_UNCOMPRESSED	BIT(5)
 #define FWHT_FL_CR_IS_UNCOMPRESSED	BIT(6)
-#define FWHT_FL_CHROMA_FULL_HEIGHT	BIT(7)
-#define FWHT_FL_CHROMA_FULL_WIDTH	BIT(8)
+#define FWHT_FL_ALPHA_IS_UNCOMPRESSED   BIT(7)
+#define FWHT_FL_CHROMA_FULL_HEIGHT	BIT(8)
+#define FWHT_FL_CHROMA_FULL_WIDTH	BIT(9)
 
 struct fwht_cframe_hdr {
 	u32 magic1;
 	u32 magic2;
 	__be32 version;
 	__be32 width, height;
+	u8 components_num;
 	__be32 flags;
 	__be32 colorspace;
 	__be32 xfer_func;
@@ -100,13 +102,20 @@ struct fwht_cframe {
 	u32 size;
 };
 
-struct fwht_raw_frame {
-	unsigned int width, height;
+#define FWHT_MAX_COMPONENTS 4
+
+struct color_component {
+	unsigned int step;
 	unsigned int width_div;
 	unsigned int height_div;
-	unsigned int luma_step;
-	unsigned int chroma_step;
-	u8 *luma, *cb, *cr;
+	u8* plane;
+};
+
+
+struct fwht_raw_frame {
+	unsigned int width, height;
+	struct color_component component[FWHT_MAX_COMPONENTS];
+	unsigned int components_num;
 };
 
 #define FWHT_FRAME_PCODED	BIT(0)
@@ -114,12 +123,13 @@ struct fwht_raw_frame {
 #define FWHT_LUMA_UNENCODED	BIT(2)
 #define FWHT_CB_UNENCODED	BIT(3)
 #define FWHT_CR_UNENCODED	BIT(4)
+#define FWHT_ALPHA_UNENCODED    BIT(5)
 
 u32 fwht_encode_frame(struct fwht_raw_frame *frm,
 		      struct fwht_raw_frame *ref_frm,
 		      struct fwht_cframe *cf,
 		      bool is_intra, bool next_is_intra);
 void fwht_decode_frame(struct fwht_cframe *cf, struct fwht_raw_frame *ref,
-		       u32 hdr_flags);
+		       u32 hdr_flags, unsigned int components_num);
 
 #endif
diff --git a/drivers/media/platform/vicodec/codec-v4l2-fwht.c b/drivers/media/platform/vicodec/codec-v4l2-fwht.c
index e5b68fb38aac..9a72f3894428 100644
--- a/drivers/media/platform/vicodec/codec-v4l2-fwht.c
+++ b/drivers/media/platform/vicodec/codec-v4l2-fwht.c
@@ -11,27 +11,27 @@
 #include "codec-v4l2-fwht.h"
 
 static const struct v4l2_fwht_pixfmt_info v4l2_fwht_pixfmts[] = {
-	{ V4L2_PIX_FMT_YUV420,  1, 3, 2, 1, 1, 2, 2 },
-	{ V4L2_PIX_FMT_YVU420,  1, 3, 2, 1, 1, 2, 2 },
-	{ V4L2_PIX_FMT_YUV422P, 1, 2, 1, 1, 1, 2, 1 },
-	{ V4L2_PIX_FMT_NV12,    1, 3, 2, 1, 2, 2, 2 },
-	{ V4L2_PIX_FMT_NV21,    1, 3, 2, 1, 2, 2, 2 },
-	{ V4L2_PIX_FMT_NV16,    1, 2, 1, 1, 2, 2, 1 },
-	{ V4L2_PIX_FMT_NV61,    1, 2, 1, 1, 2, 2, 1 },
-	{ V4L2_PIX_FMT_NV24,    1, 3, 1, 1, 2, 1, 1 },
-	{ V4L2_PIX_FMT_NV42,    1, 3, 1, 1, 2, 1, 1 },
-	{ V4L2_PIX_FMT_YUYV,    2, 2, 1, 2, 4, 2, 1 },
-	{ V4L2_PIX_FMT_YVYU,    2, 2, 1, 2, 4, 2, 1 },
-	{ V4L2_PIX_FMT_UYVY,    2, 2, 1, 2, 4, 2, 1 },
-	{ V4L2_PIX_FMT_VYUY,    2, 2, 1, 2, 4, 2, 1 },
-	{ V4L2_PIX_FMT_BGR24,   3, 3, 1, 3, 3, 1, 1 },
-	{ V4L2_PIX_FMT_RGB24,   3, 3, 1, 3, 3, 1, 1 },
-	{ V4L2_PIX_FMT_HSV24,   3, 3, 1, 3, 3, 1, 1 },
-	{ V4L2_PIX_FMT_BGR32,   4, 4, 1, 4, 4, 1, 1 },
-	{ V4L2_PIX_FMT_XBGR32,  4, 4, 1, 4, 4, 1, 1 },
-	{ V4L2_PIX_FMT_RGB32,   4, 4, 1, 4, 4, 1, 1 },
-	{ V4L2_PIX_FMT_XRGB32,  4, 4, 1, 4, 4, 1, 1 },
-	{ V4L2_PIX_FMT_HSV32,   4, 4, 1, 4, 4, 1, 1 },
+	{ V4L2_PIX_FMT_YUV420,  1, 3, 2, 1, 1, 2, 2, 3},
+	{ V4L2_PIX_FMT_YVU420,  1, 3, 2, 1, 1, 2, 2, 3},
+	{ V4L2_PIX_FMT_YUV422P, 1, 2, 1, 1, 1, 2, 1, 3},
+	{ V4L2_PIX_FMT_NV12,    1, 3, 2, 1, 2, 2, 2, 3},
+	{ V4L2_PIX_FMT_NV21,    1, 3, 2, 1, 2, 2, 2, 3},
+	{ V4L2_PIX_FMT_NV16,    1, 2, 1, 1, 2, 2, 1, 3},
+	{ V4L2_PIX_FMT_NV61,    1, 2, 1, 1, 2, 2, 1, 3},
+	{ V4L2_PIX_FMT_NV24,    1, 3, 1, 1, 2, 1, 1, 3},
+	{ V4L2_PIX_FMT_NV42,    1, 3, 1, 1, 2, 1, 1, 3},
+	{ V4L2_PIX_FMT_YUYV,    2, 2, 1, 2, 4, 2, 1, 3},
+	{ V4L2_PIX_FMT_YVYU,    2, 2, 1, 2, 4, 2, 1, 3},
+	{ V4L2_PIX_FMT_UYVY,    2, 2, 1, 2, 4, 2, 1, 3},
+	{ V4L2_PIX_FMT_VYUY,    2, 2, 1, 2, 4, 2, 1, 3},
+	{ V4L2_PIX_FMT_BGR24,   3, 3, 1, 3, 3, 1, 1, 3},
+	{ V4L2_PIX_FMT_RGB24,   3, 3, 1, 3, 3, 1, 1, 3},
+	{ V4L2_PIX_FMT_HSV24,   3, 3, 1, 3, 3, 1, 1, 3},
+	{ V4L2_PIX_FMT_BGR32,   4, 4, 1, 4, 4, 1, 1, 3},
+	{ V4L2_PIX_FMT_XBGR32,  4, 4, 1, 4, 4, 1, 1, 3},
+	{ V4L2_PIX_FMT_RGB32,   4, 4, 1, 4, 4, 1, 1, 3},
+	{ V4L2_PIX_FMT_XRGB32,  4, 4, 1, 4, 4, 1, 1, 3},
+	{ V4L2_PIX_FMT_HSV32,   4, 4, 1, 4, 4, 1, 1, 3},
 };
 
 const struct v4l2_fwht_pixfmt_info *v4l2_fwht_find_pixfmt(u32 pixelformat)
@@ -61,82 +61,98 @@ int v4l2_fwht_encode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	u32 encoding;
 	u32 flags = 0;
 
+	pr_info("dafna: %s\n",__func__);
 	if (!info)
 		return -EINVAL;
 	rf.width = state->width;
 	rf.height = state->height;
-	rf.luma = p_in;
-	rf.width_div = info->width_div;
-	rf.height_div = info->height_div;
-	rf.luma_step = info->luma_step;
-	rf.chroma_step = info->chroma_step;
+	rf.component[0].plane = p_in;
 
+	rf.component[0].width_div = 1; 
+	rf.component[1].width_div = info->width_div; 
+	rf.component[2].width_div = info->width_div;  
+	rf.component[3].width_div = info->width_div;  
+	
+	rf.component[0].height_div = 1; 
+	rf.component[1].height_div = info->height_div; 
+	rf.component[2].height_div = info->height_div;  
+	rf.component[3].height_div =info->height_div;  
+	
+	rf.component[0].step = info->first_comp_step;
+	rf.component[1].step = info->other_comp_step; 
+	rf.component[2].step = info->other_comp_step;  
+	rf.component[3].step = info->other_comp_step;  
+	
+	rf.components_num = info->components_num;
+	//rf.chroma_step = info->chroma_step;
+
+	pr_info("dafna: %s: V4L2_PIX_FMT is %u\n",__func__, info->id);
 	switch (info->id) {
 	case V4L2_PIX_FMT_YUV420:
-		rf.cb = rf.luma + size;
-		rf.cr = rf.cb + size / 4;
+		rf.component[1].plane = rf.component[0].plane + size;
+		rf.component[2].plane = rf.component[1].plane + size / 4;
 		break;
 	case V4L2_PIX_FMT_YVU420:
-		rf.cr = rf.luma + size;
-		rf.cb = rf.cr + size / 4;
+		rf.component[1].plane = rf.component[0].plane + size;
+		rf.component[2].plane = rf.component[1].plane + size / 4;
 		break;
 	case V4L2_PIX_FMT_YUV422P:
-		rf.cb = rf.luma + size;
-		rf.cr = rf.cb + size / 2;
+		rf.component[1].plane = rf.component[0].plane + size;
+		rf.component[2].plane = rf.component[2].plane + size / 2;
 		break;
 	case V4L2_PIX_FMT_NV12:
 	case V4L2_PIX_FMT_NV16:
 	case V4L2_PIX_FMT_NV24:
-		rf.cb = rf.luma + size;
-		rf.cr = rf.cb + 1;
+		rf.component[1].plane = rf.component[0].plane + size;
+		rf.component[2].plane = rf.component[1].plane + 1;
 		break;
 	case V4L2_PIX_FMT_NV21:
 	case V4L2_PIX_FMT_NV61:
 	case V4L2_PIX_FMT_NV42:
-		rf.cr = rf.luma + size;
-		rf.cb = rf.cr + 1;
+		rf.component[1].plane = rf.component[0].plane + size;
+		rf.component[2].plane = rf.component[1].plane + 1;
 		break;
 	case V4L2_PIX_FMT_YUYV:
-		rf.cb = rf.luma + 1;
-		rf.cr = rf.cb + 2;
+		rf.component[1].plane = rf.component[0].plane + 1;
+		rf.component[2].plane = rf.component[1].plane + 2;
 		break;
 	case V4L2_PIX_FMT_YVYU:
-		rf.cr = rf.luma + 1;
-		rf.cb = rf.cr + 2;
+		rf.component[2].plane = rf.component[0].plane + 1;
+		rf.component[1].plane = rf.component[2].plane + 2;
 		break;
 	case V4L2_PIX_FMT_UYVY:
-		rf.cb = rf.luma;
-		rf.cr = rf.cb + 2;
-		rf.luma++;
+		rf.component[1].plane = rf.component[0].plane;
+		rf.component[2].plane = rf.component[1].plane + 2;
+		rf.component[0].plane++;
 		break;
 	case V4L2_PIX_FMT_VYUY:
-		rf.cr = rf.luma;
-		rf.cb = rf.cr + 2;
-		rf.luma++;
+		rf.component[2].plane = rf.component[0].plane;
+		rf.component[1].plane = rf.component[2].plane + 2;
+		rf.component[0].plane++;
 		break;
 	case V4L2_PIX_FMT_RGB24:
 	case V4L2_PIX_FMT_HSV24:
-		rf.cr = rf.luma;
-		rf.cb = rf.cr + 2;
-		rf.luma++;
+		rf.component[2].plane = rf.component[0].plane;
+		rf.component[1].plane = rf.component[2].plane + 2;
+		rf.component[0].plane++;
 		break;
 	case V4L2_PIX_FMT_BGR24:
-		rf.cb = rf.luma;
-		rf.cr = rf.cb + 2;
-		rf.luma++;
+		rf.component[1].plane = rf.component[0].plane;
+		rf.component[2].plane = rf.component[2].plane + 2;
+		rf.component[0].plane++;
 		break;
 	case V4L2_PIX_FMT_RGB32:
 	case V4L2_PIX_FMT_XRGB32:
 	case V4L2_PIX_FMT_HSV32:
-		rf.cr = rf.luma + 1;
-		rf.cb = rf.cr + 2;
-		rf.luma += 2;
+		rf.component[2].plane = rf.component[0].plane + 1;
+		rf.component[1].plane = rf.component[2].plane + 2;
+		rf.component[0].plane += 2;
 		break;
 	case V4L2_PIX_FMT_BGR32:
 	case V4L2_PIX_FMT_XBGR32:
-		rf.cb = rf.luma;
-		rf.cr = rf.cb + 2;
-		rf.luma++;
+		rf.component[1].plane = rf.component[0].plane;
+		rf.component[2].plane = rf.component[1].plane + 2;
+		rf.component[0].plane++;
 		break;
 	default:
 		return -EINVAL;
@@ -148,6 +164,8 @@ int v4l2_fwht_encode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	cf.p_frame_qp = state->p_frame_qp;
 	cf.rlc_data = (__be16 *)(p_out + sizeof(*p_hdr));
 
+	pr_info("dafna: %s: fr.cr = %p fr.planes[0] = %p\n",__func__,rf.component[2].plane, rf.component[0].plane);
+
 	encoding = fwht_encode_frame(&rf, &state->ref_frame, &cf,
 				     !state->gop_cnt,
 				     state->gop_cnt == state->gop_size - 1);
@@ -162,17 +180,25 @@ int v4l2_fwht_encode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	p_hdr->version = htonl(FWHT_VERSION);
 	p_hdr->width = htonl(cf.width);
 	p_hdr->height = htonl(cf.height);
+	p_hdr->components_num = info->components_num;
 	if (encoding & FWHT_LUMA_UNENCODED)
 		flags |= FWHT_FL_LUMA_IS_UNCOMPRESSED;
 	if (encoding & FWHT_CB_UNENCODED)
 		flags |= FWHT_FL_CB_IS_UNCOMPRESSED;
 	if (encoding & FWHT_CR_UNENCODED)
 		flags |= FWHT_FL_CR_IS_UNCOMPRESSED;
-	if (rf.height_div == 1)
+	if (encoding & FWHT_ALPHA_UNENCODED)
+		flags |= FWHT_FL_ALPHA_IS_UNCOMPRESSED;
+	pr_info("dafna: %s: flag befor chroma height = 0x%x h_div = %u\n",__func__, flags,info->height_div);
+	if (info->height_div == 1)
 		flags |= FWHT_FL_CHROMA_FULL_HEIGHT;
-	if (rf.width_div == 1)
+	pr_info("dafna: %s: flag befor chroma width = 0x%x w_div = %u\n",__func__,flags, info->width_div);
+	if (info->width_div == 1)
 		flags |= FWHT_FL_CHROMA_FULL_WIDTH;
+	pr_info("dafna: %s: flag after chroma width = 0x%x\n",__func__, flags);
+
 	p_hdr->flags = htonl(flags);
+	pr_info("dafna: %s: p_hdr->flags = 0x%x\n",__func__, p_hdr->flags);
 	p_hdr->colorspace = htonl(state->colorspace);
 	p_hdr->xfer_func = htonl(state->xfer_func);
 	p_hdr->ycbcr_enc = htonl(state->ycbcr_enc);
@@ -186,124 +212,149 @@ int v4l2_fwht_encode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 int v4l2_fwht_decode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 {
 	unsigned int size = state->width * state->height;
-	unsigned int chroma_size = size;
+	unsigned int not_first_plane_sz = size;
 	unsigned int i;
 	u32 flags;
 	struct fwht_cframe_hdr *p_hdr;
 	struct fwht_cframe cf;
 	u8 *p;
+	unsigned int components_num;
 
-	if (!state->info)
+	pr_info("dafna: %s\n",__func__);
+	if (!state->info){
+		pr_info("dafna: %s ERR: no info\n",__func__);
 		return -EINVAL;
+	}
 
 	p_hdr = (struct fwht_cframe_hdr *)p_in;
 	cf.width = ntohl(p_hdr->width);
 	cf.height = ntohl(p_hdr->height);
 	flags = ntohl(p_hdr->flags);
+	components_num = p_hdr->components_num;
 	state->colorspace = ntohl(p_hdr->colorspace);
 	state->xfer_func = ntohl(p_hdr->xfer_func);
 	state->ycbcr_enc = ntohl(p_hdr->ycbcr_enc);
 	state->quantization = ntohl(p_hdr->quantization);
 	cf.rlc_data = (__be16 *)(p_in + sizeof(*p_hdr));
 
-	if (p_hdr->magic1 != FWHT_MAGIC1 ||
-	    p_hdr->magic2 != FWHT_MAGIC2 ||
-	    ntohl(p_hdr->version) != FWHT_VERSION ||
-	    (cf.width & 7) || (cf.height & 7))
+	if (p_hdr->magic1 != FWHT_MAGIC1){
+		pr_info("dafna: %s ERR magic1\n",__func__);
+		return -EINVAL;
+	}
+
+	 if(p_hdr->magic2 != FWHT_MAGIC2){
+		pr_info("dafna: %s ERR magic2\n",__func__);
+		return -EINVAL;
+	 }
+	 if(ntohl(p_hdr->version) != FWHT_VERSION){
+		pr_info("dafna: %s ERR version\n",__func__);
+		return -EINVAL;
+	
+	 }
+
+	 if((cf.width & 7) || (cf.height & 7)){
+		pr_info("dafna: %s ERR w=0x%x h=0x%x \n",__func__, cf.width, cf.height);
 		return -EINVAL;
+	}
+	pr_info("dafna: %s cf.width %u state->width %u cf.height %u state->height %u \n",
+			__func__,cf.width, state->width, cf.height, state->height);
 
 	/* TODO: support resolution changes */
 	if (cf.width != state->width || cf.height != state->height)
 		return -EINVAL;
 
+
 	if (!(flags & FWHT_FL_CHROMA_FULL_WIDTH))
-		chroma_size /= 2;
+		not_first_plane_sz /= 2;
 	if (!(flags & FWHT_FL_CHROMA_FULL_HEIGHT))
-		chroma_size /= 2;
+		not_first_plane_sz /= 2;
 
-	fwht_decode_frame(&cf, &state->ref_frame, flags);
+	pr_info("dafna: %s, about to call decode with state->ref_frame.planes[0] = %p comp num = %u\n",
+			__func__, state->ref_frame.component[0].plane, components_num);
+	
+	fwht_decode_frame(&cf, &state->ref_frame, flags, components_num);
 
 	switch (state->info->id) {
 	case V4L2_PIX_FMT_YUV420:
 	case V4L2_PIX_FMT_YUV422P:
-		memcpy(p_out, state->ref_frame.luma, size);
+		memcpy(p_out, state->ref_frame.component[0].plane, size);
 		p_out += size;
-		memcpy(p_out, state->ref_frame.cb, chroma_size);
-		p_out += chroma_size;
-		memcpy(p_out, state->ref_frame.cr, chroma_size);
+		memcpy(p_out, state->ref_frame.component[1].plane, not_first_plane_sz);
+		p_out += not_first_plane_sz;
+		memcpy(p_out, state->ref_frame.component[2].plane, not_first_plane_sz);
 		break;
 	case V4L2_PIX_FMT_YVU420:
-		memcpy(p_out, state->ref_frame.luma, size);
+		memcpy(p_out, state->ref_frame.component[0].plane, size);
 		p_out += size;
-		memcpy(p_out, state->ref_frame.cr, chroma_size);
-		p_out += chroma_size;
-		memcpy(p_out, state->ref_frame.cb, chroma_size);
+		memcpy(p_out, state->ref_frame.component[2].plane, not_first_plane_sz);
+		p_out += not_first_plane_sz;
+		memcpy(p_out, state->ref_frame.component[1].plane, not_first_plane_sz);
 		break;
 	case V4L2_PIX_FMT_NV12:
 	case V4L2_PIX_FMT_NV16:
 	case V4L2_PIX_FMT_NV24:
-		memcpy(p_out, state->ref_frame.luma, size);
+		memcpy(p_out, state->ref_frame.component[0].plane, size);
 		p_out += size;
-		for (i = 0, p = p_out; i < chroma_size; i++) {
-			*p++ = state->ref_frame.cb[i];
-			*p++ = state->ref_frame.cr[i];
+		for (i = 0, p = p_out; i < not_first_plane_sz; i++) {
+			*p++ = state->ref_frame.component[1].plane[i];
+			*p++ = state->ref_frame.component[2].plane[i];
 		}
 		break;
 	case V4L2_PIX_FMT_NV21:
 	case V4L2_PIX_FMT_NV61:
 	case V4L2_PIX_FMT_NV42:
-		memcpy(p_out, state->ref_frame.luma, size);
+		memcpy(p_out, state->ref_frame.component[0].plane, size);
 		p_out += size;
-		for (i = 0, p = p_out; i < chroma_size; i++) {
-			*p++ = state->ref_frame.cr[i];
-			*p++ = state->ref_frame.cb[i];
+		for (i = 0, p = p_out; i < not_first_plane_sz; i++) {
+			*p++ = state->ref_frame.component[2].plane[i];
+			*p++ = state->ref_frame.component[1].plane[i];
 		}
 		break;
 	case V4L2_PIX_FMT_YUYV:
 		for (i = 0, p = p_out; i < size; i += 2) {
-			*p++ = state->ref_frame.luma[i];
-			*p++ = state->ref_frame.cb[i / 2];
-			*p++ = state->ref_frame.luma[i + 1];
-			*p++ = state->ref_frame.cr[i / 2];
+			*p++ = state->ref_frame.component[0].plane[i];
+			*p++ = state->ref_frame.component[1].plane[i / 2];
+			*p++ = state->ref_frame.component[0].plane[i + 1];
+			*p++ = state->ref_frame.component[2].plane[i / 2];
 		}
 		break;
 	case V4L2_PIX_FMT_YVYU:
 		for (i = 0, p = p_out; i < size; i += 2) {
-			*p++ = state->ref_frame.luma[i];
-			*p++ = state->ref_frame.cr[i / 2];
-			*p++ = state->ref_frame.luma[i + 1];
-			*p++ = state->ref_frame.cb[i / 2];
+			*p++ = state->ref_frame.component[0].plane[i];
+			*p++ = state->ref_frame.component[2].plane[i / 2];
+			*p++ = state->ref_frame.component[0].plane[i + 1];
+			*p++ = state->ref_frame.component[1].plane[i / 2];
 		}
 		break;
 	case V4L2_PIX_FMT_UYVY:
 		for (i = 0, p = p_out; i < size; i += 2) {
-			*p++ = state->ref_frame.cb[i / 2];
-			*p++ = state->ref_frame.luma[i];
-			*p++ = state->ref_frame.cr[i / 2];
-			*p++ = state->ref_frame.luma[i + 1];
+			*p++ = state->ref_frame.component[1].plane[i / 2];
+			*p++ = state->ref_frame.component[0].plane[i];
+			*p++ = state->ref_frame.component[2].plane[i / 2];
+			*p++ = state->ref_frame.component[0].plane[i + 1];
 		}
 		break;
 	case V4L2_PIX_FMT_VYUY:
 		for (i = 0, p = p_out; i < size; i += 2) {
-			*p++ = state->ref_frame.cr[i / 2];
-			*p++ = state->ref_frame.luma[i];
-			*p++ = state->ref_frame.cb[i / 2];
-			*p++ = state->ref_frame.luma[i + 1];
+			*p++ = state->ref_frame.component[2].plane[i / 2];
+			*p++ = state->ref_frame.component[0].plane[i];
+			*p++ = state->ref_frame.component[1].plane[i / 2];
+			*p++ = state->ref_frame.component[0].plane[i + 1];
 		}
 		break;
 	case V4L2_PIX_FMT_RGB24:
 	case V4L2_PIX_FMT_HSV24:
 		for (i = 0, p = p_out; i < size; i++) {
-			*p++ = state->ref_frame.cr[i];
-			*p++ = state->ref_frame.luma[i];
-			*p++ = state->ref_frame.cb[i];
+			*p++ = state->ref_frame.component[2].plane[i];
+			*p++ = state->ref_frame.component[0].plane[i];
+			*p++ = state->ref_frame.component[1].plane[i];
 		}
 		break;
 	case V4L2_PIX_FMT_BGR24:
 		for (i = 0, p = p_out; i < size; i++) {
-			*p++ = state->ref_frame.cb[i];
-			*p++ = state->ref_frame.luma[i];
-			*p++ = state->ref_frame.cr[i];
+			*p++ = state->ref_frame.component[1].plane[i];
+			*p++ = state->ref_frame.component[0].plane[i];
+			*p++ = state->ref_frame.component[2].plane[i];
 		}
 		break;
 	case V4L2_PIX_FMT_RGB32:
@@ -311,17 +362,17 @@ int v4l2_fwht_decode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	case V4L2_PIX_FMT_HSV32:
 		for (i = 0, p = p_out; i < size; i++) {
 			*p++ = 0;
-			*p++ = state->ref_frame.cr[i];
-			*p++ = state->ref_frame.luma[i];
-			*p++ = state->ref_frame.cb[i];
+			*p++ = state->ref_frame.component[2].plane[i];
+			*p++ = state->ref_frame.component[0].plane[i];
+			*p++ = state->ref_frame.component[1].plane[i];
 		}
 		break;
 	case V4L2_PIX_FMT_BGR32:
 	case V4L2_PIX_FMT_XBGR32:
 		for (i = 0, p = p_out; i < size; i++) {
-			*p++ = state->ref_frame.cb[i];
-			*p++ = state->ref_frame.luma[i];
-			*p++ = state->ref_frame.cr[i];
+			*p++ = state->ref_frame.component[1].plane[i];
+			*p++ = state->ref_frame.component[0].plane[i];
+			*p++ = state->ref_frame.component[2].plane[i];
 			*p++ = 0;
 		}
 		break;
diff --git a/drivers/media/platform/vicodec/codec-v4l2-fwht.h b/drivers/media/platform/vicodec/codec-v4l2-fwht.h
index 162465b78067..4442dcb32703 100644
--- a/drivers/media/platform/vicodec/codec-v4l2-fwht.h
+++ b/drivers/media/platform/vicodec/codec-v4l2-fwht.h
@@ -8,16 +8,23 @@
 
 #include "codec-fwht.h"
 
+struct color_channel_info {
+	unsigned int step;
+	unsigned int width_div;
+	unsigned int height_div;
+};
+
 struct v4l2_fwht_pixfmt_info {
 	u32 id;
 	unsigned int bytesperline_mult;
 	unsigned int sizeimage_mult;
 	unsigned int sizeimage_div;
-	unsigned int luma_step;
-	unsigned int chroma_step;
+	unsigned int first_comp_step;
+	unsigned int other_comp_step;
 	/* Chroma plane subsampling */
 	unsigned int width_div;
 	unsigned int height_div;
+	unsigned int components_num;
 };
 
 struct v4l2_fwht_state {
diff --git a/drivers/media/platform/vicodec/vicodec-core.c b/drivers/media/platform/vicodec/vicodec-core.c
index 1eb9132bfc85..139c13807435 100644
--- a/drivers/media/platform/vicodec/vicodec-core.c
+++ b/drivers/media/platform/vicodec/vicodec-core.c
@@ -160,6 +160,7 @@ static int device_process(struct vicodec_ctx *ctx,
 	u8 *p_in, *p_out;
 	int ret;
 
+	pr_info("dafna: %s\n",__func__);
 	q_cap = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);
 	if (ctx->is_enc)
 		p_in = vb2_plane_vaddr(&in_vb->vb2_buf, 0);
@@ -177,12 +178,14 @@ static int device_process(struct vicodec_ctx *ctx,
 
 		q_out = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);
 		state->info = q_out->info;
+		pr_info("dafna: %s: aboout to call v4l2_fwht_encode\n", __func__);
 		ret = v4l2_fwht_encode(state, p_in, p_out);
 		if (ret < 0)
 			return ret;
 		vb2_set_plane_payload(&out_vb->vb2_buf, 0, ret);
 	} else {
 		state->info = q_cap->info;
+		pr_info("dafna: %s: aboout to call v4l2_fwht_decode\n", __func__);
 		ret = v4l2_fwht_decode(state, p_in, p_out);
 		if (ret < 0)
 			return ret;
@@ -222,11 +225,13 @@ static void device_run(void *priv)
 	struct vicodec_q_data *q_out;
 	u32 state;
 
+	pr_info("dafna: %s ctx = %p\n",__func__, ctx);
 	src_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);
 	dst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
 	q_out = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);
 
 	state = VB2_BUF_STATE_DONE;
+	pr_info("dafna: %s: about to call device_process\n",__func__);
 	if (device_process(ctx, src_buf, dst_buf))
 		state = VB2_BUF_STATE_ERROR;
 	ctx->last_dst_buf = dst_buf;
@@ -285,6 +290,7 @@ static int job_ready(void *priv)
 	u32 sz;
 	u32 state;
 
+	pr_info("dafna: %s\n", __func__);
 	if (ctx->is_enc || ctx->comp_has_frame)
 		return 1;
 
@@ -312,6 +318,8 @@ static int job_ready(void *priv)
 			copy = sizeof(magic) - ctx->comp_magic_cnt;
 			if (p_out + sz - p < copy)
 				copy = p_out + sz - p;
+			pr_info("dafna: %s copying %u to compressed_frame\n", __func__,copy);
+
 			memcpy(ctx->state.compressed_frame + ctx->comp_magic_cnt,
 			       p, copy);
 			ctx->comp_magic_cnt += copy;
@@ -336,6 +344,7 @@ static int job_ready(void *priv)
 
 		if (copy > p_out + sz - p)
 			copy = p_out + sz - p;
+		pr_info("dafna: %s copying AGAIN %u to compressed_frame\n", __func__,copy);
 		memcpy(ctx->state.compressed_frame + ctx->comp_size,
 		       p, copy);
 		p += copy;
@@ -353,6 +362,9 @@ static int job_ready(void *priv)
 
 		if (copy > p_out + sz - p)
 			copy = p_out + sz - p;
+		
+		pr_info("dafna: %s copying AGAIN AGAIN %u to compressed_frame\n", __func__,copy);
+
 		memcpy(ctx->state.compressed_frame + ctx->comp_size,
 		       p, copy);
 		p += copy;
@@ -409,6 +421,7 @@ static int enum_fmt(struct v4l2_fmtdesc *f, bool is_enc, bool is_out)
 {
 	bool is_uncomp = (is_enc && is_out) || (!is_enc && !is_out);
 
+	pr_info("dafna: enum_fmt\n");
 	if (V4L2_TYPE_IS_MULTIPLANAR(f->type) && !multiplanar)
 		return -EINVAL;
 	if (!V4L2_TYPE_IS_MULTIPLANAR(f->type) && multiplanar)
@@ -460,6 +473,7 @@ static int vidioc_g_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 	q_data = get_q_data(ctx, f->type);
 	info = q_data->info;
 
+	pr_info("dafna: vidioc_g_fmt\n");
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
@@ -471,6 +485,8 @@ static int vidioc_g_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 		pix->field = V4L2_FIELD_NONE;
 		pix->pixelformat = info->id;
 		pix->bytesperline = q_data->width * info->bytesperline_mult;
+		pr_info("dafna: %s: set pix->bytesperline(%u) = q_data->width(%u) * info->bytesperline_mult (%u)\n",__func__,
+				pix->bytesperline,q_data->width,info->bytesperline_mult);
 		pix->sizeimage = q_data->sizeimage;
 		pix->colorspace = ctx->state.colorspace;
 		pix->xfer_func = ctx->state.xfer_func;
@@ -490,6 +506,8 @@ static int vidioc_g_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 		pix_mp->num_planes = 1;
 		pix_mp->plane_fmt[0].bytesperline =
 				q_data->width * info->bytesperline_mult;
+		pr_info("dafna: %s: set pix_mp->plane_fmt[0].bytesperline(%u) = q_data->width(%u) * info->bytesperline_mult (%u)\n",__func__,
+				pix_mp->plane_fmt[0].bytesperline,q_data->width,info->bytesperline_mult);
 		pix_mp->plane_fmt[0].sizeimage = q_data->sizeimage;
 		pix_mp->colorspace = ctx->state.colorspace;
 		pix_mp->xfer_func = ctx->state.xfer_func;
@@ -523,7 +541,8 @@ static int vidioc_try_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 	struct v4l2_pix_format *pix;
 	struct v4l2_plane_pix_format *plane;
 	const struct v4l2_fwht_pixfmt_info *info = &pixfmt_fwht;
-
+	
+	pr_info("dafna: %s\n",__func__);
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
@@ -535,8 +554,15 @@ static int vidioc_try_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 		pix->field = V4L2_FIELD_NONE;
 		pix->bytesperline =
 			pix->width * info->bytesperline_mult;
+		
+		pr_info("dafna: %s: info = %p &pixfmt_fwht = %p\n",__func__, info, &pixfmt_fwht);
+		pr_info("dafna: %s: set pix->bytesperline(%u) = pix->width(%u) * info->bytesperline_mult (%u)\n",__func__, 
+				pix->bytesperline,pix->width,info->bytesperline_mult);
 		pix->sizeimage = pix->width * pix->height *
 			info->sizeimage_mult / info->sizeimage_div;
+		pr_info("dafna: %s: pix->sizeimage (%u) = pix->width (%u) * pix->height (%u) * info->sizeimage_mult (%u)/ info->sizeimage_div (%u)\n",__func__, pix->sizeimage, pix->width, pix->height,
+			info->sizeimage_mult, info->sizeimage_div);
+
 		if (pix->pixelformat == V4L2_PIX_FMT_FWHT)
 			pix->sizeimage += sizeof(struct fwht_cframe_hdr);
 		break;
@@ -573,7 +599,7 @@ static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
 	struct vicodec_ctx *ctx = file2ctx(file);
 	struct v4l2_pix_format_mplane *pix_mp;
 	struct v4l2_pix_format *pix;
-
+	pr_info("dafna: %s\n",__func__);
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 		if (multiplanar)
@@ -610,7 +636,7 @@ static int vidioc_try_fmt_vid_out(struct file *file, void *priv,
 	struct vicodec_ctx *ctx = file2ctx(file);
 	struct v4l2_pix_format_mplane *pix_mp;
 	struct v4l2_pix_format *pix;
-
+	pr_info("dafna: %s\n",__func__);
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
 		if (multiplanar)
@@ -645,6 +671,7 @@ static int vidioc_s_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 	struct v4l2_pix_format_mplane *pix_mp;
 	struct v4l2_pix_format *pix;
 
+	pr_info("dafna: vidioc_s_fmt\n");
 	vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);
 	if (!vq)
 		return -EINVAL;
@@ -670,6 +697,7 @@ static int vidioc_s_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 			q_data->info = &pixfmt_fwht;
 		else
 			q_data->info = find_fmt(pix->pixelformat);
+		pr_info("dafna: %s: q_data->info = %p &pixfmt_fwht = %p\n",__func__, q_data->info, &pixfmt_fwht);
 		q_data->width = pix->width;
 		q_data->height = pix->height;
 		q_data->sizeimage = pix->sizeimage;
@@ -709,7 +737,7 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 				struct v4l2_format *f)
 {
 	int ret;
-
+	pr_info("dafna: %s\n",__func__);
 	ret = vidioc_try_fmt_vid_cap(file, priv, f);
 	if (ret)
 		return ret;
@@ -725,6 +753,7 @@ static int vidioc_s_fmt_vid_out(struct file *file, void *priv,
 	struct v4l2_pix_format *pix;
 	int ret;
 
+	pr_info("dafna: in vidioc_s_fmt_vid_out\n");
 	ret = vidioc_try_fmt_vid_out(file, priv, f);
 	if (ret)
 		return ret;
@@ -734,7 +763,9 @@ static int vidioc_s_fmt_vid_out(struct file *file, void *priv,
 		switch (f->type) {
 		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 		case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+			pr_info("dafna: %s: case V4L2_BUF_TYPE_VIDEO_OUTPUT/CAPTURE: setting ctx from format\n",__func__);
 			pix = &f->fmt.pix;
+			pr_info("dafna: %s: case V4L2_.._OUTPUT/CAPTURE: setting ctx from format %d\n",__func__, pix->pixelformat);
 			ctx->state.colorspace = pix->colorspace;
 			ctx->state.xfer_func = pix->xfer_func;
 			ctx->state.ycbcr_enc = pix->ycbcr_enc;
@@ -993,28 +1024,45 @@ static int vicodec_start_streaming(struct vb2_queue *q,
 	unsigned int size = q_data->width * q_data->height;
 	const struct v4l2_fwht_pixfmt_info *info = q_data->info;
 	unsigned int chroma_div = info->width_div * info->height_div;
+	unsigned int components_num;
+	unsigned int total_planes_size;
+
+	//we don't ahead how many componenets are in the encoding type
+	//V4L2_PIX_FMT_FWHT, so we will use the maximal
+	if(info->id == V4L2_PIX_FMT_FWHT)
+		components_num = FWHT_MAX_COMPONENTS;
+	else
+		components_num = info->components_num;
+
+	total_planes_size = size + components_num * (size / chroma_div);
 
 	q_data->sequence = 0;
+	pr_info("dafna: %s ctx=%p, id=%u components_num = %u total = %u\n",
+			__func__, ctx, info->id, components_num, total_planes_size);
 
-	if (!V4L2_TYPE_IS_OUTPUT(q->type))
+	if (!V4L2_TYPE_IS_OUTPUT(q->type)){
+		pr_info("dafna: %s got !V4L2_TYPE_IS_OUTPUT returning\n",__func__);
 		return 0;
+	}
 
 	state->width = q_data->width;
 	state->height = q_data->height;
 	state->ref_frame.width = state->ref_frame.height = 0;
-	state->ref_frame.luma = kvmalloc(size + 2 * size / chroma_div,
-					 GFP_KERNEL);
-	ctx->comp_max_size = size + 2 * size / chroma_div +
-			     sizeof(struct fwht_cframe_hdr);
+	state->ref_frame.component[0].plane = kvmalloc(total_planes_size, GFP_KERNEL);
+	ctx->comp_max_size = total_planes_size + sizeof(struct fwht_cframe_hdr);
 	state->compressed_frame = kvmalloc(ctx->comp_max_size, GFP_KERNEL);
-	if (!state->ref_frame.luma || !state->compressed_frame) {
-		kvfree(state->ref_frame.luma);
+	
+	pr_info("dafna: %s compressed_frame = %p ref_componenet 0 plane = %p\n",
+			__func__, state->compressed_frame, state->ref_frame.component[0].plane);
+
+	if (!state->ref_frame.component[0].plane || !state->compressed_frame) {
+		kvfree(state->ref_frame.component[0].plane);
 		kvfree(state->compressed_frame);
 		vicodec_return_bufs(q, VB2_BUF_STATE_QUEUED);
 		return -ENOMEM;
 	}
-	state->ref_frame.cb = state->ref_frame.luma + size;
-	state->ref_frame.cr = state->ref_frame.cb + size / chroma_div;
+	state->ref_frame.component[1].plane = state->ref_frame.component[0].plane + size;
+	state->ref_frame.component[2].plane = state->ref_frame.component[1].plane + (size / chroma_div);
 	ctx->last_src_buf = NULL;
 	ctx->last_dst_buf = NULL;
 	state->gop_cnt = 0;
@@ -1035,7 +1083,7 @@ static void vicodec_stop_streaming(struct vb2_queue *q)
 	if (!V4L2_TYPE_IS_OUTPUT(q->type))
 		return;
 
-	kvfree(ctx->state.ref_frame.luma);
+	kvfree(ctx->state.ref_frame.component[0].plane);
 	kvfree(ctx->state.compressed_frame);
 }
 
@@ -1054,7 +1102,7 @@ static int queue_init(void *priv, struct vb2_queue *src_vq,
 {
 	struct vicodec_ctx *ctx = priv;
 	int ret;
-
+	pr_info("dafna: %s\n",__func__);
 	src_vq->type = (multiplanar ?
 			V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE :
 			V4L2_BUF_TYPE_VIDEO_OUTPUT);
@@ -1093,7 +1141,7 @@ static int vicodec_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct vicodec_ctx *ctx = container_of(ctrl->handler,
 					       struct vicodec_ctx, hdl);
-
+	pr_info("dafna: %s\n",__func__);
 	switch (ctrl->id) {
 	case V4L2_CID_MPEG_VIDEO_GOP_SIZE:
 		ctx->state.gop_size = ctrl->val;
@@ -1146,6 +1194,7 @@ static int vicodec_open(struct file *file)
 	unsigned int size;
 	int rc = 0;
 
+	pr_info("dafna: %s\n",__func__);
 	if (mutex_lock_interruptible(vfd->lock))
 		return -ERESTARTSYS;
 	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
