From 6e84c6d76f445ba8ae1233c022c866f8dff5d3f2 Mon Sep 17 00:00:00 2001
From: Dafna Hirschfeld <dafna3@gmail.com>
Date: Thu, 18 Oct 2018 16:41:32 +0300
Subject: [PATCH] support gryscale basic

---
 drivers/media/platform/vicodec/codec-fwht.c   | 21 ++++++---
 .../media/platform/vicodec/codec-v4l2-fwht.c  | 43 ++++++++++++++++---
 drivers/media/platform/vicodec/vicodec-core.c | 23 ++++++++--
 3 files changed, 73 insertions(+), 14 deletions(-)

diff --git a/drivers/media/platform/vicodec/codec-fwht.c b/drivers/media/platform/vicodec/codec-fwht.c
index 5e15b340cfc3..a40dea78be41 100644
--- a/drivers/media/platform/vicodec/codec-fwht.c
+++ b/drivers/media/platform/vicodec/codec-fwht.c
@@ -671,7 +671,7 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 	unsigned int last_size = 0;
 	unsigned int i, j;
 	
-	pr_info("dafna: %s: start\n",__func__);
+	pr_info("dafna: %s: start w=%u h=%u\n",__func__,width,height);
 	for (j = 0; j < height / 8; j++) {
 		for (i = 0; i < width / 8; i++) {
 			/* intra code, first frame is always intra coded. */
@@ -728,6 +728,7 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 
 exit_loop:
 	if (encoding & FWHT_FRAME_UNENCODED) {
+		pr_info("dafna: %s: plane unencoded\n",__func__);
 		u8 *out = (u8 *)rlco_start;
 
 		input = input_start;
@@ -742,6 +743,7 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 		*rlco = (__be16 *)out;
 		encoding &= ~FWHT_FRAME_PCODED;
 	}
+	pr_info("dafna: %s: end\n",__func__);
 	return encoding;
 }
 
@@ -756,9 +758,11 @@ u32 fwht_encode_frame(struct fwht_raw_frame *frm,
 	u32 encoding;
 	u32 chroma_h = frm->height / frm->height_div;
 	u32 chroma_w = frm->width / frm->width_div;
-	//if (!frm->cr || !frm->cb) {
-	//	chroma_h = chroma_w = 0;
-	//}
+	pr_info("dafna: %s: frm->cr = %p frm->cb = %p\n",__func__, frm->cr, frm->cb);
+	if (!frm->cr || !frm->cb) {
+		pr_info("dafna: %s: setting chroma_[wh] to 0\n",__func__);
+		chroma_h = chroma_w = 0;
+	}
 	
 	unsigned int chroma_size = chroma_h * chroma_w;
 
@@ -772,13 +776,13 @@ u32 fwht_encode_frame(struct fwht_raw_frame *frm,
 	encoding &= ~FWHT_FRAME_UNENCODED;
 	rlco_max = rlco + chroma_size / 2 - 256;
 
-	printk(KERN_DEBUG  "dafna: %s dumping 10 bytes of cf->rlc_data(%p) after luma",__func__, cf->rlc_data);
+	printk(KERN_DEBUG  "dafna: %s dumping 10 bytes of cf->rlc_data(%p) after LUMA",__func__, cf->rlc_data);
 	print_hex_dump_bytes("", DUMP_PREFIX_NONE, cf->rlc_data,10);
 
 	encoding |= encode_plane(frm->cb, ref_frm->cb, &rlco, rlco_max, cf,
 				 chroma_h, chroma_w,
 				 frm->chroma_step, is_intra, next_is_intra);
-	printk(KERN_DEBUG  "dafna: %s dumping 10 bytes of cf->rlc_data(%p) after cb",__func__, cf->rlc_data);
+	printk(KERN_DEBUG  "dafna: %s dumping 10 bytes of cf->rlc_data(%p) after CB",__func__, cf->rlc_data);
 	print_hex_dump_bytes("", DUMP_PREFIX_NONE, cf->rlc_data,10);
 
 	if (encoding & FWHT_FRAME_UNENCODED)
@@ -862,8 +866,13 @@ void fwht_decode_frame(struct fwht_cframe *cf, struct fwht_raw_frame *ref,
 		h *= 2;
 	if (hdr_flags & FWHT_FL_CHROMA_FULL_WIDTH)
 		w *= 2;
+	
 	decode_plane(cf, &rlco, ref->luma, cf->height, cf->width,
 		     hdr_flags & FWHT_FL_LUMA_IS_UNCOMPRESSED);
+	if(!ref->cb || !ref->cr) {
+		pr_info("dafna: %s: !cr or !cb, setting w=h=0\n",__func__);
+		w = h = 0;
+	}
 	decode_plane(cf, &rlco, ref->cb, h, w,
 		     hdr_flags & FWHT_FL_CB_IS_UNCOMPRESSED);
 	decode_plane(cf, &rlco, ref->cr, h, w,
diff --git a/drivers/media/platform/vicodec/codec-v4l2-fwht.c b/drivers/media/platform/vicodec/codec-v4l2-fwht.c
index 3605d8b248d9..33382a603c32 100644
--- a/drivers/media/platform/vicodec/codec-v4l2-fwht.c
+++ b/drivers/media/platform/vicodec/codec-v4l2-fwht.c
@@ -11,6 +11,7 @@
 #include "codec-v4l2-fwht.h"
 
 static const struct v4l2_fwht_pixfmt_info v4l2_fwht_pixfmts[] = {
+	{ V4L2_PIX_FMT_GREY,    1, 1, 1, 1, 0, 1, 1 },
 	{ V4L2_PIX_FMT_YUV420,  1, 3, 2, 1, 1, 2, 2 },
 	{ V4L2_PIX_FMT_YVU420,  1, 3, 2, 1, 1, 2, 2 },
 	{ V4L2_PIX_FMT_YUV422P, 1, 2, 1, 1, 1, 2, 1 },
@@ -72,7 +73,14 @@ int v4l2_fwht_encode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	rf.luma_step = info->luma_step;
 	rf.chroma_step = info->chroma_step;
 
+	pr_info("dafna: %s: V4L2_PIX_FMT is %u\n",__func__, info->id);
 	switch (info->id) {
+	case V4L2_PIX_FMT_GREY:
+		pr_info("dafna: %s: GREY case\n",__func__);
+		rf.cb = rf.cr = NULL;
+		pr_info("dafna: %s: fr.cr = %p fr.cb = %p\n",__func__, 
+				rf.cr, rf.cb);
+		break;	
 	case V4L2_PIX_FMT_YUV420:
 		rf.cb = rf.luma + size;
 		rf.cr = rf.cb + size / 4;
@@ -149,6 +157,8 @@ int v4l2_fwht_encode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	cf.p_frame_qp = state->p_frame_qp;
 	cf.rlc_data = (__be16 *)(p_out + sizeof(*p_hdr));
 
+	pr_info("dafna: %s: fr.cr = %p fr.cb = %p\n",__func__,rf.cr, rf.cb);
+
 	encoding = fwht_encode_frame(&rf, &state->ref_frame, &cf,
 				     !state->gop_cnt,
 				     state->gop_cnt == state->gop_size - 1);
@@ -195,8 +205,10 @@ int v4l2_fwht_decode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	u8 *p;
 
 	pr_info("dafna: %s\n",__func__);
-	if (!state->info)
+	if (!state->info){
+		pr_info("dafna: %s ERR: no info\n",__func__);
 		return -EINVAL;
+	}
 
 	p_hdr = (struct fwht_cframe_hdr *)p_in;
 	cf.width = ntohl(p_hdr->width);
@@ -208,11 +220,27 @@ int v4l2_fwht_decode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	state->quantization = ntohl(p_hdr->quantization);
 	cf.rlc_data = (__be16 *)(p_in + sizeof(*p_hdr));
 
-	if (p_hdr->magic1 != FWHT_MAGIC1 ||
-	    p_hdr->magic2 != FWHT_MAGIC2 ||
-	    ntohl(p_hdr->version) != FWHT_VERSION ||
-	    (cf.width & 7) || (cf.height & 7))
+	if (p_hdr->magic1 != FWHT_MAGIC1){
+		pr_info("dafna: %s ERR magic1\n",__func__);
+		return -EINVAL;
+	}
+
+	 if(p_hdr->magic2 != FWHT_MAGIC2){
+		pr_info("dafna: %s ERR magic2\n",__func__);
+		return -EINVAL;
+	 }
+	 if(ntohl(p_hdr->version) != FWHT_VERSION){
+		pr_info("dafna: %s ERR version\n",__func__);
 		return -EINVAL;
+	
+	 }
+
+	 if((cf.width & 7) || (cf.height & 7)){
+		pr_info("dafna: %s ERR w=0x%x h=0x%x \n",__func__, cf.width, cf.height);
+		return -EINVAL;
+	}
+	pr_info("dafna: %s cf.width %u state->width %u cf.height %u state->height %u \n",
+			__func__,cf.width, state->width, cf.height, state->height);
 
 	/* TODO: support resolution changes */
 	if (cf.width != state->width || cf.height != state->height)
@@ -223,9 +251,14 @@ int v4l2_fwht_decode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	if (!(flags & FWHT_FL_CHROMA_FULL_HEIGHT))
 		chroma_size /= 2;
 
+	pr_info("dafna: %s, about to call decode with state->ref_frame.cr = %p, state->ref_frame.cb = %p\n",__func__, state->ref_frame.cr, state->ref_frame.cb);
+	
 	fwht_decode_frame(&cf, &state->ref_frame, flags);
 
 	switch (state->info->id) {
+	case V4L2_PIX_FMT_GREY:
+		memcpy(p_out, state->ref_frame.luma, size);
+		break;
 	case V4L2_PIX_FMT_YUV420:
 	case V4L2_PIX_FMT_YUV422P:
 		memcpy(p_out, state->ref_frame.luma, size);
diff --git a/drivers/media/platform/vicodec/vicodec-core.c b/drivers/media/platform/vicodec/vicodec-core.c
index 5cf18ac7a510..4b7f7d3d4d97 100644
--- a/drivers/media/platform/vicodec/vicodec-core.c
+++ b/drivers/media/platform/vicodec/vicodec-core.c
@@ -185,6 +185,7 @@ static int device_process(struct vicodec_ctx *ctx,
 		vb2_set_plane_payload(&out_vb->vb2_buf, 0, ret);
 	} else {
 		state->info = q_cap->info;
+		pr_info("dafna: %s: aboout to call v4l2_fwht_decode\n", __func__);
 		ret = v4l2_fwht_decode(state, p_in, p_out);
 		if (ret < 0)
 			return ret;
@@ -224,12 +225,13 @@ static void device_run(void *priv)
 	struct vicodec_q_data *q_out;
 	u32 state;
 
-	pr_info("dafna: %s\n",__func__);
+	pr_info("dafna: %s ctx = %p\n",__func__, ctx);
 	src_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);
 	dst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
 	q_out = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);
 
 	state = VB2_BUF_STATE_DONE;
+	pr_info("dafna: %s: about to call device_process\n",__func__);
 	if (device_process(ctx, src_buf, dst_buf))
 		state = VB2_BUF_STATE_ERROR;
 	ctx->last_dst_buf = dst_buf;
@@ -288,6 +290,7 @@ static int job_ready(void *priv)
 	u32 sz;
 	u32 state;
 
+	pr_info("dafna: %s\n", __func__);
 	if (ctx->is_enc || ctx->comp_has_frame)
 		return 1;
 
@@ -315,6 +318,8 @@ static int job_ready(void *priv)
 			copy = sizeof(magic) - ctx->comp_magic_cnt;
 			if (p_out + sz - p < copy)
 				copy = p_out + sz - p;
+			pr_info("dafna: %s copying %u to compressed_frame\n", __func__,copy);
+
 			memcpy(ctx->state.compressed_frame + ctx->comp_magic_cnt,
 			       p, copy);
 			ctx->comp_magic_cnt += copy;
@@ -339,6 +344,7 @@ static int job_ready(void *priv)
 
 		if (copy > p_out + sz - p)
 			copy = p_out + sz - p;
+		pr_info("dafna: %s copying AGAIN %u to compressed_frame\n", __func__,copy);
 		memcpy(ctx->state.compressed_frame + ctx->comp_size,
 		       p, copy);
 		p += copy;
@@ -356,6 +362,9 @@ static int job_ready(void *priv)
 
 		if (copy > p_out + sz - p)
 			copy = p_out + sz - p;
+		
+		pr_info("dafna: %s copying AGAIN AGAIN %u to compressed_frame\n", __func__,copy);
+
 		memcpy(ctx->state.compressed_frame + ctx->comp_size,
 		       p, copy);
 		p += copy;
@@ -1014,9 +1023,11 @@ static int vicodec_start_streaming(struct vb2_queue *q,
 	unsigned int chroma_div = info->width_div * info->height_div;
 
 	q_data->sequence = 0;
-
-	if (!V4L2_TYPE_IS_OUTPUT(q->type))
+	pr_info("dafna: %s ctx=%p, id=%u\n",__func__, ctx, info->id);
+	if (!V4L2_TYPE_IS_OUTPUT(q->type)){
+		pr_info("dafna: %s got !V4L2_TYPE_IS_OUTPUT returning\n",__func__);
 		return 0;
+	}
 
 	state->width = q_data->width;
 	state->height = q_data->height;
@@ -1034,6 +1045,12 @@ static int vicodec_start_streaming(struct vb2_queue *q,
 	}
 	state->ref_frame.cb = state->ref_frame.luma + size;
 	state->ref_frame.cr = state->ref_frame.cb + size / chroma_div;
+	
+	if(info->id == V4L2_PIX_FMT_GREY) {
+		pr_info("dafna: %s ctx=%p, id is grey, setting cb cr to NULL\n",__func__, ctx);
+		state->ref_frame.cb = NULL;
+		state->ref_frame.cr = NULL;
+	}
 	ctx->last_src_buf = NULL;
 	ctx->last_dst_buf = NULL;
 	state->gop_cnt = 0;
-- 
2.17.1

