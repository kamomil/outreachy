From 610359a766279787b9c1b016796097cbea91f702 Mon Sep 17 00:00:00 2001
From: Dafna Hirschfeld <dafna3@gmail.com>
Date: Sat, 6 Oct 2018 11:16:48 +0300
Subject: [PATCH 1/2] dafna prints

---
 drivers/media/platform/vicodec/codec-fwht.c   | 22 ++++++++-
 .../media/platform/vicodec/codec-v4l2-fwht.c  | 35 ++++++++++++--
 drivers/media/platform/vicodec/vicodec-core.c | 47 +++++++++++++++----
 drivers/media/v4l2-core/v4l2-compat-ioctl32.c |  1 +
 drivers/media/v4l2-core/v4l2-dev.c            |  2 +-
 drivers/media/v4l2-core/v4l2-ioctl.c          |  9 +++-
 drivers/media/v4l2-core/v4l2-mem2mem.c        |  6 ++-
 7 files changed, 103 insertions(+), 19 deletions(-)

diff --git a/drivers/media/platform/vicodec/codec-fwht.c b/drivers/media/platform/vicodec/codec-fwht.c
index 36656031b295..6a496feef5d2 100644
--- a/drivers/media/platform/vicodec/codec-fwht.c
+++ b/drivers/media/platform/vicodec/codec-fwht.c
@@ -11,7 +11,7 @@
 
 #include <linux/string.h>
 #include "codec-fwht.h"
-
+#include <linux/videodev2.h>
 /*
  * Note: bit 0 of the header must always be 0. Otherwise it cannot
  * be guaranteed that the magic 8 byte sequence (see below) can
@@ -670,7 +670,8 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 	u32 encoding = 0;
 	unsigned int last_size = 0;
 	unsigned int i, j;
-
+	
+	pr_info("dafna: %s: start w=%u h=%u\n",__func__,width,height);
 	for (j = 0; j < height / 8; j++) {
 		for (i = 0; i < width / 8; i++) {
 			/* intra code, first frame is always intra coded. */
@@ -727,6 +728,7 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 
 exit_loop:
 	if (encoding & FWHT_FRAME_UNENCODED) {
+		pr_info("dafna: %s: plane unencoded\n",__func__);
 		u8 *out = (u8 *)rlco_start;
 
 		input = input_start;
@@ -741,6 +743,7 @@ static u32 encode_plane(u8 *input, u8 *refp, __be16 **rlco, __be16 *rlco_max,
 		*rlco = (__be16 *)out;
 		encoding &= ~FWHT_FRAME_PCODED;
 	}
+	pr_info("dafna: %s: end\n",__func__);
 	return encoding;
 }
 
@@ -755,8 +758,13 @@ u32 fwht_encode_frame(struct fwht_raw_frame *frm,
 	u32 encoding;
 	u32 chroma_h = frm->height / frm->height_div;
 	u32 chroma_w = frm->width / frm->width_div;
+	//if (!frm->cr || !frm->cb) {
+	//	chroma_h = chroma_w = 0;
+	//}
+	
 	unsigned int chroma_size = chroma_h * chroma_w;
 
+	printk(KERN_DEBUG  "dafna: %s rlco = %p\n",__func__,rlco);
 	rlco_max = rlco + size / 2 - 256;
 	encoding = encode_plane(frm->luma, ref_frm->luma, &rlco, rlco_max, cf,
 				frm->height, frm->width,
@@ -765,9 +773,16 @@ u32 fwht_encode_frame(struct fwht_raw_frame *frm,
 		encoding |= FWHT_LUMA_UNENCODED;
 	encoding &= ~FWHT_FRAME_UNENCODED;
 	rlco_max = rlco + chroma_size / 2 - 256;
+
+	printk(KERN_DEBUG  "dafna: %s dumping 10 bytes of cf->rlc_data(%p) after LUMA",__func__, cf->rlc_data);
+	print_hex_dump_bytes("", DUMP_PREFIX_NONE, cf->rlc_data,10);
+
 	encoding |= encode_plane(frm->cb, ref_frm->cb, &rlco, rlco_max, cf,
 				 chroma_h, chroma_w,
 				 frm->chroma_step, is_intra, next_is_intra);
+	printk(KERN_DEBUG  "dafna: %s dumping 10 bytes of cf->rlc_data(%p) after CB",__func__, cf->rlc_data);
+	print_hex_dump_bytes("", DUMP_PREFIX_NONE, cf->rlc_data,10);
+
 	if (encoding & FWHT_FRAME_UNENCODED)
 		encoding |= FWHT_CB_UNENCODED;
 	encoding &= ~FWHT_FRAME_UNENCODED;
@@ -778,6 +793,8 @@ u32 fwht_encode_frame(struct fwht_raw_frame *frm,
 	if (encoding & FWHT_FRAME_UNENCODED)
 		encoding |= FWHT_CR_UNENCODED;
 	encoding &= ~FWHT_FRAME_UNENCODED;
+	printk(KERN_DEBUG  "dafna: %s\n: end, cf->rlc_data = %p, rlco = %p\n",__func__,cf->rlc_data, rlco);
+
 	cf->size = (rlco - cf->rlc_data) * sizeof(*rlco);
 	return encoding;
 }
@@ -842,6 +859,7 @@ void fwht_decode_frame(struct fwht_cframe *cf, struct fwht_raw_frame *ref,
 	u32 h = cf->height / 2;
 	u32 w = cf->width / 2;
 
+	//printk(KERN_DEBUG "dafna: %s\n",__func__);
 	if (hdr_flags & FWHT_FL_CHROMA_FULL_HEIGHT)
 		h *= 2;
 	if (hdr_flags & FWHT_FL_CHROMA_FULL_WIDTH)
diff --git a/drivers/media/platform/vicodec/codec-v4l2-fwht.c b/drivers/media/platform/vicodec/codec-v4l2-fwht.c
index e5b68fb38aac..121492a33647 100644
--- a/drivers/media/platform/vicodec/codec-v4l2-fwht.c
+++ b/drivers/media/platform/vicodec/codec-v4l2-fwht.c
@@ -61,6 +61,7 @@ int v4l2_fwht_encode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	u32 encoding;
 	u32 flags = 0;
 
+	pr_info("dafna: %s\n",__func__);
 	if (!info)
 		return -EINVAL;
 	rf.width = state->width;
@@ -71,6 +72,7 @@ int v4l2_fwht_encode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	rf.luma_step = info->luma_step;
 	rf.chroma_step = info->chroma_step;
 
+	pr_info("dafna: %s: V4L2_PIX_FMT is %u\n",__func__, info->id);
 	switch (info->id) {
 	case V4L2_PIX_FMT_YUV420:
 		rf.cb = rf.luma + size;
@@ -148,6 +150,8 @@ int v4l2_fwht_encode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	cf.p_frame_qp = state->p_frame_qp;
 	cf.rlc_data = (__be16 *)(p_out + sizeof(*p_hdr));
 
+	pr_info("dafna: %s: fr.cr = %p fr.cb = %p\n",__func__,rf.cr, rf.cb);
+
 	encoding = fwht_encode_frame(&rf, &state->ref_frame, &cf,
 				     !state->gop_cnt,
 				     state->gop_cnt == state->gop_size - 1);
@@ -193,8 +197,11 @@ int v4l2_fwht_decode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	struct fwht_cframe cf;
 	u8 *p;
 
-	if (!state->info)
+	pr_info("dafna: %s\n",__func__);
+	if (!state->info){
+		pr_info("dafna: %s ERR: no info\n",__func__);
 		return -EINVAL;
+	}
 
 	p_hdr = (struct fwht_cframe_hdr *)p_in;
 	cf.width = ntohl(p_hdr->width);
@@ -206,11 +213,27 @@ int v4l2_fwht_decode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	state->quantization = ntohl(p_hdr->quantization);
 	cf.rlc_data = (__be16 *)(p_in + sizeof(*p_hdr));
 
-	if (p_hdr->magic1 != FWHT_MAGIC1 ||
-	    p_hdr->magic2 != FWHT_MAGIC2 ||
-	    ntohl(p_hdr->version) != FWHT_VERSION ||
-	    (cf.width & 7) || (cf.height & 7))
+	if (p_hdr->magic1 != FWHT_MAGIC1){
+		pr_info("dafna: %s ERR magic1\n",__func__);
+		return -EINVAL;
+	}
+
+	 if(p_hdr->magic2 != FWHT_MAGIC2){
+		pr_info("dafna: %s ERR magic2\n",__func__);
 		return -EINVAL;
+	 }
+	 if(ntohl(p_hdr->version) != FWHT_VERSION){
+		pr_info("dafna: %s ERR version\n",__func__);
+		return -EINVAL;
+	
+	 }
+
+	 if((cf.width & 7) || (cf.height & 7)){
+		pr_info("dafna: %s ERR w=0x%x h=0x%x \n",__func__, cf.width, cf.height);
+		return -EINVAL;
+	}
+	pr_info("dafna: %s cf.width %u state->width %u cf.height %u state->height %u \n",
+			__func__,cf.width, state->width, cf.height, state->height);
 
 	/* TODO: support resolution changes */
 	if (cf.width != state->width || cf.height != state->height)
@@ -221,6 +244,8 @@ int v4l2_fwht_decode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	if (!(flags & FWHT_FL_CHROMA_FULL_HEIGHT))
 		chroma_size /= 2;
 
+	pr_info("dafna: %s, about to call decode with state->ref_frame.cr = %p, state->ref_frame.cb = %p\n",__func__, state->ref_frame.cr, state->ref_frame.cb);
+	
 	fwht_decode_frame(&cf, &state->ref_frame, flags);
 
 	switch (state->info->id) {
diff --git a/drivers/media/platform/vicodec/vicodec-core.c b/drivers/media/platform/vicodec/vicodec-core.c
index 1eb9132bfc85..d53723eac40f 100644
--- a/drivers/media/platform/vicodec/vicodec-core.c
+++ b/drivers/media/platform/vicodec/vicodec-core.c
@@ -160,6 +160,7 @@ static int device_process(struct vicodec_ctx *ctx,
 	u8 *p_in, *p_out;
 	int ret;
 
+	pr_info("dafna: %s\n",__func__);
 	q_cap = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);
 	if (ctx->is_enc)
 		p_in = vb2_plane_vaddr(&in_vb->vb2_buf, 0);
@@ -177,12 +178,14 @@ static int device_process(struct vicodec_ctx *ctx,
 
 		q_out = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);
 		state->info = q_out->info;
+		pr_info("dafna: %s: aboout to call v4l2_fwht_encode\n", __func__);
 		ret = v4l2_fwht_encode(state, p_in, p_out);
 		if (ret < 0)
 			return ret;
 		vb2_set_plane_payload(&out_vb->vb2_buf, 0, ret);
 	} else {
 		state->info = q_cap->info;
+		pr_info("dafna: %s: aboout to call v4l2_fwht_decode\n", __func__);
 		ret = v4l2_fwht_decode(state, p_in, p_out);
 		if (ret < 0)
 			return ret;
@@ -222,11 +225,13 @@ static void device_run(void *priv)
 	struct vicodec_q_data *q_out;
 	u32 state;
 
+	pr_info("dafna: %s ctx = %p\n",__func__, ctx);
 	src_buf = v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);
 	dst_buf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
 	q_out = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);
 
 	state = VB2_BUF_STATE_DONE;
+	pr_info("dafna: %s: about to call device_process\n",__func__);
 	if (device_process(ctx, src_buf, dst_buf))
 		state = VB2_BUF_STATE_ERROR;
 	ctx->last_dst_buf = dst_buf;
@@ -285,6 +290,7 @@ static int job_ready(void *priv)
 	u32 sz;
 	u32 state;
 
+	pr_info("dafna: %s\n", __func__);
 	if (ctx->is_enc || ctx->comp_has_frame)
 		return 1;
 
@@ -312,6 +318,8 @@ static int job_ready(void *priv)
 			copy = sizeof(magic) - ctx->comp_magic_cnt;
 			if (p_out + sz - p < copy)
 				copy = p_out + sz - p;
+			pr_info("dafna: %s copying %u to compressed_frame\n", __func__,copy);
+
 			memcpy(ctx->state.compressed_frame + ctx->comp_magic_cnt,
 			       p, copy);
 			ctx->comp_magic_cnt += copy;
@@ -336,6 +344,7 @@ static int job_ready(void *priv)
 
 		if (copy > p_out + sz - p)
 			copy = p_out + sz - p;
+		pr_info("dafna: %s copying AGAIN %u to compressed_frame\n", __func__,copy);
 		memcpy(ctx->state.compressed_frame + ctx->comp_size,
 		       p, copy);
 		p += copy;
@@ -353,6 +362,9 @@ static int job_ready(void *priv)
 
 		if (copy > p_out + sz - p)
 			copy = p_out + sz - p;
+		
+		pr_info("dafna: %s copying AGAIN AGAIN %u to compressed_frame\n", __func__,copy);
+
 		memcpy(ctx->state.compressed_frame + ctx->comp_size,
 		       p, copy);
 		p += copy;
@@ -409,6 +421,7 @@ static int enum_fmt(struct v4l2_fmtdesc *f, bool is_enc, bool is_out)
 {
 	bool is_uncomp = (is_enc && is_out) || (!is_enc && !is_out);
 
+	pr_info("dafna: enum_fmt\n");
 	if (V4L2_TYPE_IS_MULTIPLANAR(f->type) && !multiplanar)
 		return -EINVAL;
 	if (!V4L2_TYPE_IS_MULTIPLANAR(f->type) && multiplanar)
@@ -460,6 +473,7 @@ static int vidioc_g_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 	q_data = get_q_data(ctx, f->type);
 	info = q_data->info;
 
+	pr_info("dafna: vidioc_g_fmt\n");
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
@@ -471,6 +485,8 @@ static int vidioc_g_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 		pix->field = V4L2_FIELD_NONE;
 		pix->pixelformat = info->id;
 		pix->bytesperline = q_data->width * info->bytesperline_mult;
+		pr_info("dafna: %s: set pix->bytesperline(%u) = q_data->width(%u) * info->bytesperline_mult (%u)\n",__func__,
+				pix->bytesperline,q_data->width,info->bytesperline_mult);
 		pix->sizeimage = q_data->sizeimage;
 		pix->colorspace = ctx->state.colorspace;
 		pix->xfer_func = ctx->state.xfer_func;
@@ -490,6 +506,8 @@ static int vidioc_g_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 		pix_mp->num_planes = 1;
 		pix_mp->plane_fmt[0].bytesperline =
 				q_data->width * info->bytesperline_mult;
+		pr_info("dafna: %s: set pix_mp->plane_fmt[0].bytesperline(%u) = q_data->width(%u) * info->bytesperline_mult (%u)\n",__func__,
+				pix_mp->plane_fmt[0].bytesperline,q_data->width,info->bytesperline_mult);
 		pix_mp->plane_fmt[0].sizeimage = q_data->sizeimage;
 		pix_mp->colorspace = ctx->state.colorspace;
 		pix_mp->xfer_func = ctx->state.xfer_func;
@@ -523,7 +541,8 @@ static int vidioc_try_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 	struct v4l2_pix_format *pix;
 	struct v4l2_plane_pix_format *plane;
 	const struct v4l2_fwht_pixfmt_info *info = &pixfmt_fwht;
-
+	
+	pr_info("dafna: %s\n",__func__);
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
@@ -535,8 +554,13 @@ static int vidioc_try_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 		pix->field = V4L2_FIELD_NONE;
 		pix->bytesperline =
 			pix->width * info->bytesperline_mult;
+		pr_info("dafna: %s: set pix->bytesperline(%u) = pix->width(%u) * info->bytesperline_mult (%u)\n",__func__, 
+				pix->bytesperline,pix->width,info->bytesperline_mult);
 		pix->sizeimage = pix->width * pix->height *
 			info->sizeimage_mult / info->sizeimage_div;
+		pr_info("dafna: %s: pix->sizeimage (%u) = pix->width (%u) * pix->height (%u) * info->sizeimage_mult (%u)/ info->sizeimage_div (%u)\n",__func__, pix->sizeimage, pix->width, pix->height,
+			info->sizeimage_mult, info->sizeimage_div);
+
 		if (pix->pixelformat == V4L2_PIX_FMT_FWHT)
 			pix->sizeimage += sizeof(struct fwht_cframe_hdr);
 		break;
@@ -573,7 +597,7 @@ static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
 	struct vicodec_ctx *ctx = file2ctx(file);
 	struct v4l2_pix_format_mplane *pix_mp;
 	struct v4l2_pix_format *pix;
-
+	pr_info("dafna: %s\n",__func__);
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 		if (multiplanar)
@@ -610,7 +634,7 @@ static int vidioc_try_fmt_vid_out(struct file *file, void *priv,
 	struct vicodec_ctx *ctx = file2ctx(file);
 	struct v4l2_pix_format_mplane *pix_mp;
 	struct v4l2_pix_format *pix;
-
+	pr_info("dafna: %s\n",__func__);
 	switch (f->type) {
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
 		if (multiplanar)
@@ -645,6 +669,7 @@ static int vidioc_s_fmt(struct vicodec_ctx *ctx, struct v4l2_format *f)
 	struct v4l2_pix_format_mplane *pix_mp;
 	struct v4l2_pix_format *pix;
 
+	pr_info("dafna: vidioc_s_fmt\n");
 	vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);
 	if (!vq)
 		return -EINVAL;
@@ -709,7 +734,7 @@ static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
 				struct v4l2_format *f)
 {
 	int ret;
-
+	pr_info("dafna: %s\n",__func__);
 	ret = vidioc_try_fmt_vid_cap(file, priv, f);
 	if (ret)
 		return ret;
@@ -725,6 +750,7 @@ static int vidioc_s_fmt_vid_out(struct file *file, void *priv,
 	struct v4l2_pix_format *pix;
 	int ret;
 
+	pr_info("dafna: in vidioc_s_fmt_vid_out\n");
 	ret = vidioc_try_fmt_vid_out(file, priv, f);
 	if (ret)
 		return ret;
@@ -734,7 +760,9 @@ static int vidioc_s_fmt_vid_out(struct file *file, void *priv,
 		switch (f->type) {
 		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 		case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+			pr_info("dafna: %s: case V4L2_BUF_TYPE_VIDEO_OUTPUT/CAPTURE: setting ctx from format\n",__func__);
 			pix = &f->fmt.pix;
+			pr_info("dafna: %s: case V4L2_.._OUTPUT/CAPTURE: setting ctx from format %d\n",__func__, pix->pixelformat);
 			ctx->state.colorspace = pix->colorspace;
 			ctx->state.xfer_func = pix->xfer_func;
 			ctx->state.ycbcr_enc = pix->ycbcr_enc;
@@ -995,9 +1023,11 @@ static int vicodec_start_streaming(struct vb2_queue *q,
 	unsigned int chroma_div = info->width_div * info->height_div;
 
 	q_data->sequence = 0;
-
-	if (!V4L2_TYPE_IS_OUTPUT(q->type))
+	pr_info("dafna: %s ctx=%p, id=%u\n",__func__, ctx, info->id);
+	if (!V4L2_TYPE_IS_OUTPUT(q->type)){
+		pr_info("dafna: %s got !V4L2_TYPE_IS_OUTPUT returning\n",__func__);
 		return 0;
+	}
 
 	state->width = q_data->width;
 	state->height = q_data->height;
@@ -1054,7 +1084,7 @@ static int queue_init(void *priv, struct vb2_queue *src_vq,
 {
 	struct vicodec_ctx *ctx = priv;
 	int ret;
-
+	pr_info("dafna: %s\n",__func__);
 	src_vq->type = (multiplanar ?
 			V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE :
 			V4L2_BUF_TYPE_VIDEO_OUTPUT);
@@ -1093,7 +1123,7 @@ static int vicodec_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct vicodec_ctx *ctx = container_of(ctrl->handler,
 					       struct vicodec_ctx, hdl);
-
+	pr_info("dafna: %s\n",__func__);
 	switch (ctrl->id) {
 	case V4L2_CID_MPEG_VIDEO_GOP_SIZE:
 		ctx->state.gop_size = ctrl->val;
@@ -1146,6 +1176,7 @@ static int vicodec_open(struct file *file)
 	unsigned int size;
 	int rc = 0;
 
+	pr_info("dafna: %s\n",__func__);
 	if (mutex_lock_interruptible(vfd->lock))
 		return -ERESTARTSYS;
 	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
diff --git a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c
index 6481212fda77..be826ce0e29e 100644
--- a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c
+++ b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c
@@ -1238,6 +1238,7 @@ static long do_video_ioctl(struct file *file, unsigned int cmd, unsigned long ar
 	case VIDIOC_G_FMT:
 	case VIDIOC_S_FMT:
 	case VIDIOC_TRY_FMT:
+        pr_info("do_video_ioctl: case VIDIOC_G_FMT/VIDIOC_G_FMT/VIDIOC_TRY_FMT %d\n",cmd);
 		err = bufsize_v4l2_format(p32, &aux_space);
 		if (!err)
 			err = alloc_userspace(sizeof(struct v4l2_format),
diff --git a/drivers/media/v4l2-core/v4l2-dev.c b/drivers/media/v4l2-core/v4l2-dev.c
index 69e775930fc4..986827d60047 100644
--- a/drivers/media/v4l2-core/v4l2-dev.c
+++ b/drivers/media/v4l2-core/v4l2-dev.c
@@ -1048,7 +1048,7 @@ static int __init videodev_init(void)
 	dev_t dev = MKDEV(VIDEO_MAJOR, 0);
 	int ret;
 
-	pr_info("Linux video capture interface: v2.00\n");
+	pr_info("Linux video capture interface: v2.00 dafna\n");
 	ret = register_chrdev_region(dev, VIDEO_NUM_DEVICES, VIDEO_NAME);
 	if (ret < 0) {
 		pr_warn("videodev: unable to get major %d\n",
diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2-ioctl.c
index 7de041bae84f..cf76bcbe7991 100644
--- a/drivers/media/v4l2-core/v4l2-ioctl.c
+++ b/drivers/media/v4l2-core/v4l2-ioctl.c
@@ -1511,9 +1511,12 @@ static int v4l_s_fmt(const struct v4l2_ioctl_ops *ops,
 	struct video_device *vfd = video_devdata(file);
 	int ret = check_fmt(file, p->type);
 
+	pr_info("dafna: in v4l_s_fmt");
 	if (ret)
 		return ret;
 
+	//this does mothing for most drivers
+	//as enable_source is not defined
 	ret = v4l_enable_media_source(vfd);
 	if (ret)
 		return ret;
@@ -1551,12 +1554,16 @@ static int v4l_s_fmt(const struct v4l2_ioctl_ops *ops,
 		CLEAR_AFTER_FIELD(p, fmt.sliced);
 		return ops->vidioc_s_fmt_sliced_vbi_cap(file, fh, arg);
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-		if (unlikely(!ops->vidioc_s_fmt_vid_out))
+		if (unlikely(!ops->vidioc_s_fmt_vid_out)){
+			pr_info("dafna: %s: ops->vidioc_s_fmt_vid_out not defined\n",__func__);
 			break;
+		}
 		CLEAR_AFTER_FIELD(p, fmt.pix);
+		pr_info("dafna: calling ops->vidioc_s_fmt_vid_out\n");
 		ret = ops->vidioc_s_fmt_vid_out(file, fh, arg);
 		/* just in case the driver zeroed it again */
 		p->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;
+		pr_info("dafna: %s: returning %d\n",__func__, ret);
 		return ret;
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
 		if (unlikely(!ops->vidioc_s_fmt_vid_out_mplane))
diff --git a/drivers/media/v4l2-core/v4l2-mem2mem.c b/drivers/media/v4l2-core/v4l2-mem2mem.c
index ce9bd1b91210..81f5b10ff8a1 100644
--- a/drivers/media/v4l2-core/v4l2-mem2mem.c
+++ b/drivers/media/v4l2-core/v4l2-mem2mem.c
@@ -268,6 +268,7 @@ static void v4l2_m2m_try_run(struct v4l2_m2m_dev *m2m_dev)
 	spin_unlock_irqrestore(&m2m_dev->job_spinlock, flags);
 
 	dprintk("Running job on m2m_ctx: %p\n", m2m_dev->curr_ctx);
+	pr_info("dafna: %s: about to call device_run callback, m2m_dev = %p\n",__func__, m2m_dev);
 	m2m_dev->m2m_ops->device_run(m2m_dev->curr_ctx->priv);
 }
 
@@ -359,7 +360,7 @@ static void __v4l2_m2m_try_queue(struct v4l2_m2m_dev *m2m_dev,
 void v4l2_m2m_try_schedule(struct v4l2_m2m_ctx *m2m_ctx)
 {
 	struct v4l2_m2m_dev *m2m_dev = m2m_ctx->m2m_dev;
-
+	pr_info("dafna: %s: m2m_dev = %p\n",__func__, m2m_dev);
 	__v4l2_m2m_try_queue(m2m_dev, m2m_ctx);
 	v4l2_m2m_try_run(m2m_dev);
 }
@@ -983,7 +984,8 @@ int v4l2_m2m_ioctl_qbuf(struct file *file, void *priv,
 				struct v4l2_buffer *buf)
 {
 	struct v4l2_fh *fh = file->private_data;
-
+	pr_info("dafna: %s: v4l2_fh = %p\n",__func__, fh);
+	
 	return v4l2_m2m_qbuf(file, fh->m2m_ctx, buf);
 }
 EXPORT_SYMBOL_GPL(v4l2_m2m_ioctl_qbuf);
-- 
2.17.1

