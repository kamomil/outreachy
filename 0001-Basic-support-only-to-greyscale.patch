From 712e6503c75379a220ccf5d33db7085d2d272876 Mon Sep 17 00:00:00 2001
From: Dafna Hirschfeld <dafna3@gmail.com>
Date: Sat, 20 Oct 2018 13:06:59 +0300
Subject: [PATCH] Basic support only to greyscale

---
 drivers/media/platform/vicodec/codec-fwht.c      | 7 +++++++
 drivers/media/platform/vicodec/codec-v4l2-fwht.c | 7 +++++++
 drivers/media/platform/vicodec/vicodec-core.c    | 6 ++++++
 3 files changed, 20 insertions(+)

diff --git a/drivers/media/platform/vicodec/codec-fwht.c b/drivers/media/platform/vicodec/codec-fwht.c
index 36656031b295..e530d3934e79 100644
--- a/drivers/media/platform/vicodec/codec-fwht.c
+++ b/drivers/media/platform/vicodec/codec-fwht.c
@@ -755,6 +755,9 @@ u32 fwht_encode_frame(struct fwht_raw_frame *frm,
 	u32 encoding;
 	u32 chroma_h = frm->height / frm->height_div;
 	u32 chroma_w = frm->width / frm->width_div;
+	if (!frm->cr || !frm->cb)
+		chroma_h = chroma_w = 0;
+
 	unsigned int chroma_size = chroma_h * chroma_w;
 
 	rlco_max = rlco + size / 2 - 256;
@@ -848,6 +851,10 @@ void fwht_decode_frame(struct fwht_cframe *cf, struct fwht_raw_frame *ref,
 		w *= 2;
 	decode_plane(cf, &rlco, ref->luma, cf->height, cf->width,
 		     hdr_flags & FWHT_FL_LUMA_IS_UNCOMPRESSED);
+
+	if(!ref->cb || !ref->cr)
+		w = h = 0;
+
 	decode_plane(cf, &rlco, ref->cb, h, w,
 		     hdr_flags & FWHT_FL_CB_IS_UNCOMPRESSED);
 	decode_plane(cf, &rlco, ref->cr, h, w,
diff --git a/drivers/media/platform/vicodec/codec-v4l2-fwht.c b/drivers/media/platform/vicodec/codec-v4l2-fwht.c
index e5b68fb38aac..ca7efa40264e 100644
--- a/drivers/media/platform/vicodec/codec-v4l2-fwht.c
+++ b/drivers/media/platform/vicodec/codec-v4l2-fwht.c
@@ -11,6 +11,7 @@
 #include "codec-v4l2-fwht.h"
 
 static const struct v4l2_fwht_pixfmt_info v4l2_fwht_pixfmts[] = {
+	{ V4L2_PIX_FMT_GREY,    1, 1, 1, 1, 0, 1, 1 },
 	{ V4L2_PIX_FMT_YUV420,  1, 3, 2, 1, 1, 2, 2 },
 	{ V4L2_PIX_FMT_YVU420,  1, 3, 2, 1, 1, 2, 2 },
 	{ V4L2_PIX_FMT_YUV422P, 1, 2, 1, 1, 1, 2, 1 },
@@ -72,6 +73,9 @@ int v4l2_fwht_encode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	rf.chroma_step = info->chroma_step;
 
 	switch (info->id) {
+	case V4L2_PIX_FMT_GREY:
+		rf.cb = rf.cr = NULL;
+		break;
 	case V4L2_PIX_FMT_YUV420:
 		rf.cb = rf.luma + size;
 		rf.cr = rf.cb + size / 4;
@@ -224,6 +228,9 @@ int v4l2_fwht_decode(struct v4l2_fwht_state *state, u8 *p_in, u8 *p_out)
 	fwht_decode_frame(&cf, &state->ref_frame, flags);
 
 	switch (state->info->id) {
+	case V4L2_PIX_FMT_GREY:
+		memcpy(p_out, state->ref_frame.luma, size);
+		break;
 	case V4L2_PIX_FMT_YUV420:
 	case V4L2_PIX_FMT_YUV422P:
 		memcpy(p_out, state->ref_frame.luma, size);
diff --git a/drivers/media/platform/vicodec/vicodec-core.c b/drivers/media/platform/vicodec/vicodec-core.c
index 1eb9132bfc85..9e0bd2045fb3 100644
--- a/drivers/media/platform/vicodec/vicodec-core.c
+++ b/drivers/media/platform/vicodec/vicodec-core.c
@@ -1015,6 +1015,12 @@ static int vicodec_start_streaming(struct vb2_queue *q,
 	}
 	state->ref_frame.cb = state->ref_frame.luma + size;
 	state->ref_frame.cr = state->ref_frame.cb + size / chroma_div;
+
+	if(info->id == V4L2_PIX_FMT_GREY) {
+		pr_debug("%s ctx=%p, id is grey, setting cb cr to NULL\n",__func__, ctx);
+		state->ref_frame.cb = NULL;
+		state->ref_frame.cr = NULL;
+	}
 	ctx->last_src_buf = NULL;
 	ctx->last_dst_buf = NULL;
 	state->gop_cnt = 0;
-- 
2.17.1

